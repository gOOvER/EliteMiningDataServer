[{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\clients\\eddnClient.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'topic' is assigned a value but never used.","line":27,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":30},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":73,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":73,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2104,2105],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2104,2104],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'schemaVersion' is assigned a value but never used.","line":79,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":24}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const zmq = require('zeromq')\nconst zlib = require('zlib')\nconst EventEmitter = require('events')\nconst logger = require('../services/logger')\n\nclass EDDNClient extends EventEmitter {\n  constructor (config) {\n    super()\n    this.relayUrl = config.relayUrl || 'tcp://eddn.edcd.io:9500'\n    this.reconnectInterval = config.reconnectInterval || 30000\n    this.socket = null\n    this.isConnected = false\n    this.reconnectTimer = null\n    this.messageCount = 0\n    this.startTime = Date.now()\n  }\n\n  async connect () {\n    try {\n      this.socket = new zmq.Subscriber()\n      this.socket.connect(this.relayUrl)\n      this.socket.subscribe('')\n\n      logger.info(`EDDN: Connecting to ${this.relayUrl}`)\n\n      // Listen for messages\n      for await (const [topic, message] of this.socket) {\n        this.handleMessage(message)\n      }\n    } catch (error) {\n      logger.error('EDDN: Connection error:', error)\n      this.scheduleReconnect()\n    }\n  }\n\n  handleMessage (compressedMessage) {\n    try {\n      // Decompress the message\n      const decompressed = zlib.inflateSync(compressedMessage)\n      const data = JSON.parse(decompressed.toString('utf8'))\n\n      this.messageCount++\n\n      // Filter for mining-relevant messages\n      if (this.isMiningRelevant(data)) {\n        this.emit('miningData', data)\n      }\n\n      // Emit all data for other uses\n      this.emit('data', data)\n\n      // Log statistics every 1000 messages\n      if (this.messageCount % 1000 === 0) {\n        const uptime = (Date.now() - this.startTime) / 1000\n        const messagesPerSecond = (this.messageCount / uptime).toFixed(2)\n        logger.info(`EDDN: Processed ${this.messageCount} messages (${messagesPerSecond} msg/s)`)\n      }\n    } catch (error) {\n      logger.error('EDDN: Message parsing error:', error)\n    }\n  }\n\n  isMiningRelevant (data) {\n    const schema = data.$schemaRef\n    const message = data.message\n    const header = data.header\n\n    if (!schema || !message) {\n      return false\n    }\n\n    // Extract schema type from URL (based on EDDN documentation)\n    const schemaMatch = schema.match(/\\/schemas\\/([^\\/]+)\\/(\\d+)/)\n    if (!schemaMatch) {\n      return false\n    }\n\n    const schemaType = schemaMatch[1]\n    const schemaVersion = parseInt(schemaMatch[2])\n\n    // Mining-relevant schema types based on EDDN documentation\n    const miningSchemas = [\n      'commodity', // Market data for mining commodities\n      'journal', // Player journal events\n      'outfitting', // Mining equipment availability\n      'shipyard', // Mining ship availability\n      'fsssignaldiscovered', // Fleet Carrier signals (mining locations)\n      'navbeaconscan' // Navigation beacon data\n    ]\n\n    if (!miningSchemas.includes(schemaType)) {\n      return false\n    }\n\n    // Enhanced filtering for journal events (based on EDDN dev docs)\n    if (schemaType === 'journal' && message.event) {\n      const miningEvents = [\n        // Core mining events\n        'MiningRefined', 'AsteroidCracked', 'ProspectedAsteroid',\n        'LaunchDrones', 'CollectCargo', 'Cargo', 'Materials',\n\n        // Location and movement for mining spots\n        'Docked', 'Location', 'FSDJump', 'CarrierJump',\n        'SupercruiseEntry', 'SupercruiseExit',\n\n        // Market and trading\n        'Market', 'MarketBuy', 'MarketSell', 'CommodityPricesUpdated',\n\n        // Ship and equipment for mining builds\n        'Loadout', 'ModuleInfo', 'ShipyardBuy', 'ShipyardSell',\n        'OutfittingBuy', 'OutfittingSell',\n\n        // Exploration for finding mining sites\n        'Scan', 'FSSDiscoveryScan', 'SAAScanComplete', 'FSSSignalDiscovered',\n\n        // SRV operations for surface mining\n        'LaunchSRV', 'DockSRV'\n      ]\n\n      if (!miningEvents.includes(message.event)) {\n        return false\n      }\n\n      // Additional filtering for market transactions\n      if (message.event === 'MarketSell' || message.event === 'MarketBuy') {\n        const commodity = message.Type\n        return this.isMiningCommodity(commodity)\n      }\n    }\n\n    // Enhanced filtering for commodity messages (based on market data)\n    if (schemaType === 'commodity') {\n      if (message.commodities && Array.isArray(message.commodities)) {\n        // Check if any commodity is mining-related\n        return message.commodities.some(commodity =>\n          this.isMiningCommodity(commodity.name)\n        )\n      }\n    }\n\n    // For outfitting and shipyard, filter by game version and expansion support\n    if ((schemaType === 'outfitting' || schemaType === 'shipyard') && header) {\n      // Prefer Odyssey/Horizons data for better mining equipment info\n      if (message.horizons || message.odyssey) {\n        return true\n      }\n    }\n\n    return true\n  }\n\n  isMiningCommodity (commodityName) {\n    if (!commodityName) return false\n\n    const name = commodityName.toLowerCase()\n\n    // Comprehensive list of mining commodities (from Elite Dangerous data)\n    const miningCommodities = [\n      // Core mining (void opals, diamonds, etc.)\n      'voidopals', 'lowtemperaturediamond', 'alexandrite', 'benitoite',\n      'grandidierite', 'monazite', 'musgravite', 'rhodplumsite',\n      'serendibite', 'taaffeite',\n\n      // Laser mining (metallic rings)\n      'painite', 'platinum', 'osmium', 'gold', 'silver', 'palladium',\n      'bertrandite', 'indite', 'gallite', 'cobalt', 'rutile',\n      'chromium', 'manganese', 'zinc', 'arsenic', 'niobium',\n      'yttrium', 'cadmium', 'mercury', 'molybdenum', 'technetium',\n      'tellurium', 'selenium', 'polonium', 'antimonium', 'thallium',\n\n      // Surface mining / SRV materials\n      'praseodymium', 'samarium', 'bromelite', 'methanol',\n      'methanolmonohydratecrystals', 'liquidoxygen', 'water',\n\n      // Tritium (carrier fuel from ice rings)\n      'tritium',\n\n      // Common metals\n      'iron', 'nickel', 'copper', 'tin', 'aluminum', 'lead'\n    ]\n\n    return miningCommodities.some(commodity =>\n      name.includes(commodity) || commodity.includes(name)\n    )\n  }\n\n  scheduleReconnect () {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n    }\n\n    this.reconnectTimer = setTimeout(() => {\n      logger.info('EDDN: Attempting to reconnect...')\n      this.connect()\n    }, this.reconnectInterval)\n  }\n\n  disconnect () {\n    if (this.socket) {\n      this.socket.close()\n      this.socket = null\n    }\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n    }\n\n    this.isConnected = false\n    logger.info('EDDN: Disconnected')\n  }\n\n  getStatistics () {\n    const uptime = (Date.now() - this.startTime) / 1000\n    return {\n      connected: this.isConnected,\n      messageCount: this.messageCount,\n      uptime,\n      messagesPerSecond: (this.messageCount / uptime).toFixed(2)\n    }\n  }\n}\n\nmodule.exports = EDDNClient\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\clients\\edsmClient.js","messages":[{"ruleId":"promise/param-names","severity":2,"message":"Promise constructor parameters must be named to match \"^_?resolve$\"","line":40,"column":29,"nodeType":"Identifier","messageId":"resolveParamNames","endLine":40,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const axios = require('axios')\nconst logger = require('../services/logger')\n\nclass EDSMClient {\n  constructor (config) {\n    this.systemApiUrl = 'https://www.edsm.net/api-v1/'\n    this.logsApiUrl = 'https://www.edsm.net/api-logs-v1/'\n    this.commanderName = config.commanderName || null\n    this.apiKey = config.apiKey || null\n\n    // Rate limiting based on EDSM recommendations\n    this.rateLimitDelay = 500 // 0.5 second between requests\n    this.lastRequestTime = 0\n    this.requestQueue = []\n    this.isProcessingQueue = false\n  }\n\n  async makeRequest (url, params = {}) {\n    return new Promise((resolve, reject) => {\n      this.requestQueue.push({ url, params, resolve, reject })\n      this.processQueue()\n    })\n  }\n\n  async processQueue () {\n    if (this.isProcessingQueue || this.requestQueue.length === 0) {\n      return\n    }\n\n    this.isProcessingQueue = true\n\n    while (this.requestQueue.length > 0) {\n      const { url, params, resolve, reject } = this.requestQueue.shift()\n\n      try {\n        // Rate limiting\n        const now = Date.now()\n        const timeSinceLastRequest = now - this.lastRequestTime\n        if (timeSinceLastRequest < this.rateLimitDelay) {\n          await new Promise(res => setTimeout(res, this.rateLimitDelay - timeSinceLastRequest))\n        }\n\n        const response = await this.executeRequest(url, params)\n        this.lastRequestTime = Date.now()\n        resolve(response)\n      } catch (error) {\n        reject(error)\n      }\n    }\n\n    this.isProcessingQueue = false\n  }\n\n  async executeRequest (url, params) {\n    try {\n      const response = await axios.get(url, {\n        params,\n        headers: {\n          'User-Agent': 'EliteMiningDataServer/1.0.0'\n        },\n        timeout: 30000\n      })\n\n      return response.data\n    } catch (error) {\n      logger.error('EDSM API request failed:', error.message)\n      throw error\n    }\n  }\n\n  async getSystemInfo (systemName) {\n    try {\n      const data = await this.makeRequest('system', {\n        systemName,\n        showInformation: 1,\n        showCoordinates: 1,\n        showPrimaryStar: 1\n      })\n\n      return data\n    } catch (error) {\n      logger.error(`Failed to get system info for ${systemName}:`, error.message)\n      return null\n    }\n  }\n\n  async getSystemBodies (systemName) {\n    try {\n      const data = await this.makeRequest('system', {\n        systemName,\n        showInformation: 1,\n        showCoordinates: 1,\n        showPrimaryStar: 1,\n        showBodies: 1\n      })\n\n      return data?.bodies || []\n    } catch (error) {\n      logger.error(`Failed to get system bodies for ${systemName}:`, error.message)\n      return []\n    }\n  }\n\n  async getNearbySystemsWithMaterials (systemName, radius = 50) {\n    try {\n      // First get the reference system coordinates\n      const systemInfo = await this.getSystemInfo(systemName)\n      if (!systemInfo || !systemInfo.coords) {\n        throw new Error(`Could not find coordinates for system ${systemName}`)\n      }\n\n      const { x, y, z } = systemInfo.coords\n\n      // Get nearby systems\n      const data = await this.makeRequest('sphere-systems', {\n        x,\n        y,\n        z,\n        radius,\n        showInformation: 1,\n        showCoordinates: 1\n      })\n\n      return data || []\n    } catch (error) {\n      logger.error(`Failed to get nearby systems for ${systemName}:`, error.message)\n      return []\n    }\n  }\n\n  async getSystemStations (systemName) {\n    try {\n      const data = await this.makeRequest('system', {\n        systemName,\n        showStations: 1\n      })\n\n      return data?.stations || []\n    } catch (error) {\n      logger.error(`Failed to get stations for ${systemName}:`, error.message)\n      return []\n    }\n  }\n\n  async findSystemsByName (searchTerm, limit = 10) {\n    try {\n      const data = await this.makeRequest('systems', {\n        startswith: searchTerm,\n        showInformation: 1,\n        showCoordinates: 1\n      })\n\n      // Limit results\n      return (data || []).slice(0, limit)\n    } catch (error) {\n      logger.error(`Failed to search systems with term \"${searchTerm}\":`, error.message)\n      return []\n    }\n  }\n\n  async getDistanceBetweenSystems (system1, system2) {\n    try {\n      const [info1, info2] = await Promise.all([\n        this.getSystemInfo(system1),\n        this.getSystemInfo(system2)\n      ])\n\n      if (!info1?.coords || !info2?.coords) {\n        throw new Error('Could not get coordinates for one or both systems')\n      }\n\n      const dx = info1.coords.x - info2.coords.x\n      const dy = info1.coords.y - info2.coords.y\n      const dz = info1.coords.z - info2.coords.z\n\n      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n      return {\n        system1,\n        system2,\n        distance: Math.round(distance * 100) / 100,\n        coords1: info1.coords,\n        coords2: info2.coords\n      }\n    } catch (error) {\n      logger.error(`Failed to calculate distance between ${system1} and ${system2}:`, error.message)\n      return null\n    }\n  }\n\n  async getMiningSystemsNearby (systemName, radius = 100) {\n    try {\n      const nearbySystems = await this.getNearbySystemsWithMaterials(systemName, radius)\n      const miningSystems = []\n\n      // Process systems to find those with mining potential\n      for (const system of nearbySystems.slice(0, 50)) { // Limit to first 50 to avoid rate limits\n        await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay))\n\n        try {\n          const bodies = await this.getSystemBodies(system.name)\n\n          // Look for asteroid belts and rings\n          const miningBodies = bodies.filter(body =>\n            body.type === 'Belt' ||\n            (body.rings && body.rings.length > 0) ||\n            body.subType === 'Metal rich body' ||\n            body.subType === 'High metal content body'\n          )\n\n          if (miningBodies.length > 0) {\n            miningSystems.push({\n              ...system,\n              miningBodies,\n              distance: system.distance\n            })\n          }\n        } catch (bodyError) {\n          logger.warn(`Could not get bodies for system ${system.name}:`, bodyError.message)\n        }\n      }\n\n      return miningSystems.sort((a, b) => a.distance - b.distance)\n    } catch (error) {\n      logger.error(`Failed to find mining systems near ${systemName}:`, error.message)\n      return []\n    }\n  }\n\n  async getTrafficReport () {\n    try {\n      const data = await this.makeRequest('stats')\n      return data\n    } catch (error) {\n      logger.error('Failed to get EDSM traffic report:', error.message)\n      return null\n    }\n  }\n\n  async delay () {\n    return new Promise(resolve => setTimeout(resolve, this.rateLimitDelay))\n  }\n}\n\nmodule.exports = EDSMClient\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\clients\\inaraClient.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\advancedIndexManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\aggregationPipelines.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\dataArchival.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\enhancedDatabaseManager.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'archivalStats' is assigned a value but never used.","line":537,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":537,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Database Manager for Elite Mining Data Server\n * Integrates indexing, time-series handling, archival, and aggregation pipelines\n */\n\nconst MongoIndexManager = require('./mongoIndexes')\nconst TimeSeriesDataHandler = require('./timeSeriesHandler')\nconst DataArchivalManager = require('./dataArchival')\nconst AggregationPipelines = require('./aggregationPipelines')\nconst logger = require('../services/logger')\n\nclass EnhancedDatabaseManager {\n  constructor (mongoService) {\n    this.db = mongoService\n    this.indexManager = new MongoIndexManager(mongoService)\n    this.timeSeriesHandler = new TimeSeriesDataHandler(mongoService)\n    this.archivalManager = new DataArchivalManager(mongoService)\n    this.isInitialized = false\n  }\n\n  /**\n   * Initialize the enhanced database features\n   */\n  async initialize () {\n    try {\n      logger.info('Initializing enhanced database features...')\n\n      // Create all production indexes\n      await this.indexManager.createAllIndexes()\n\n      // Schedule automatic archival process (runs daily at 2 AM)\n      this.scheduleArchivalProcess()\n\n      // Schedule index maintenance (runs weekly)\n      this.scheduleIndexMaintenance()\n\n      this.isInitialized = true\n      logger.info('Enhanced database features initialized successfully')\n\n      return {\n        status: 'success',\n        features: {\n          indexes: 'created',\n          timeSeriesHandler: 'ready',\n          archivalManager: 'scheduled',\n          aggregationPipelines: 'available'\n        }\n      }\n    } catch (error) {\n      logger.error('Failed to initialize enhanced database features:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Get comprehensive database statistics\n   */\n  async getDatabaseStatistics () {\n    try {\n      const stats = {\n        collections: {},\n        indexes: await this.indexManager.getIndexStats(),\n        archival: await this.archivalManager.getArchivalStatistics(),\n        performance: await this.getPerformanceMetrics(),\n        storage: await this.getStorageStatistics()\n      }\n\n      // Get collection statistics\n      const collections = ['market_data', 'mining_locations', 'systems', 'stations', 'statistics', 'eddn_messages', 'api_usage']\n\n      for (const collectionName of collections) {\n        try {\n          const collection = this.db.getCollection(collectionName)\n          const collectionStats = await collection.stats()\n\n          stats.collections[collectionName] = {\n            documentCount: collectionStats.count || 0,\n            avgDocumentSize: collectionStats.avgObjSize || 0,\n            storageSize: collectionStats.storageSize || 0,\n            indexSize: collectionStats.totalIndexSize || 0,\n            dataSize: collectionStats.size || 0\n          }\n        } catch (error) {\n          stats.collections[collectionName] = { error: error.message }\n        }\n      }\n\n      return stats\n    } catch (error) {\n      logger.error('Failed to get database statistics:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Execute market data aggregation with caching\n   */\n  async getMarketAnalytics (type, ...params) {\n    const cacheKey = `market_analytics_${type}_${JSON.stringify(params)}`\n\n    try {\n      // Check cache first (if available)\n      const cachedResult = await this.getCachedResult(cacheKey)\n      if (cachedResult) {\n        return cachedResult\n      }\n\n      const collection = this.db.getCollection('market_data')\n      let result\n\n      switch (type) {\n        case 'commodityTrends':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'commodityPriceTrends', 'market', ...params\n          )\n          break\n        case 'tradingRoutes':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'tradingRoutes', 'market', ...params\n          )\n          break\n        case 'systemSummary':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'systemMarketSummary', 'market', ...params\n          )\n          break\n        default:\n          throw new Error(`Unknown market analytics type: ${type}`)\n      }\n\n      // Cache result for 15 minutes\n      await this.setCachedResult(cacheKey, result, 15 * 60)\n\n      return result\n    } catch (error) {\n      logger.error(`Failed to get market analytics (${type}):`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Execute mining data aggregation\n   */\n  async getMiningAnalytics (type, ...params) {\n    const cacheKey = `mining_analytics_${type}_${JSON.stringify(params)}`\n\n    try {\n      const cachedResult = await this.getCachedResult(cacheKey)\n      if (cachedResult) {\n        return cachedResult\n      }\n\n      const collection = this.db.getCollection('mining_locations')\n      let result\n\n      switch (type) {\n        case 'profitability':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'miningProfitability', 'mining', ...params\n          )\n          break\n        case 'hotspots':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'hotspotAnalysis', 'mining', ...params\n          )\n          break\n        default:\n          throw new Error(`Unknown mining analytics type: ${type}`)\n      }\n\n      await this.setCachedResult(cacheKey, result, 20 * 60) // Cache for 20 minutes\n\n      return result\n    } catch (error) {\n      logger.error(`Failed to get mining analytics (${type}):`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Execute statistics aggregation\n   */\n  async getStatisticsAnalytics (type, ...params) {\n    const cacheKey = `stats_analytics_${type}_${JSON.stringify(params)}`\n\n    try {\n      const cachedResult = await this.getCachedResult(cacheKey)\n      if (cachedResult) {\n        return cachedResult\n      }\n\n      let result\n      let collection\n\n      switch (type) {\n        case 'global':\n          collection = this.db.getCollection('statistics')\n          result = await AggregationPipelines.executePipeline(\n            collection, 'globalStats', 'statistics', ...params\n          )\n          break\n        case 'apiUsage':\n          collection = this.db.getCollection('api_usage')\n          result = await AggregationPipelines.executePipeline(\n            collection, 'apiUsageAnalytics', 'statistics', ...params\n          )\n          break\n        default:\n          throw new Error(`Unknown statistics analytics type: ${type}`)\n      }\n\n      await this.setCachedResult(cacheKey, result, 10 * 60) // Cache for 10 minutes\n\n      return result\n    } catch (error) {\n      logger.error(`Failed to get statistics analytics (${type}):`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Execute EDDN analytics\n   */\n  async getEDDNAnalytics (type, ...params) {\n    const cacheKey = `eddn_analytics_${type}_${JSON.stringify(params)}`\n\n    try {\n      const cachedResult = await this.getCachedResult(cacheKey)\n      if (cachedResult) {\n        return cachedResult\n      }\n\n      const collection = this.db.getCollection('eddn_messages')\n      let result\n\n      switch (type) {\n        case 'messageStats':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'eddnMessageStats', 'eddn', ...params\n          )\n          break\n        case 'sourceAnalysis':\n          result = await AggregationPipelines.executePipeline(\n            collection, 'eddnSourceAnalysis', 'eddn', ...params\n          )\n          break\n        default:\n          throw new Error(`Unknown EDDN analytics type: ${type}`)\n      }\n\n      await this.setCachedResult(cacheKey, result, 5 * 60) // Cache for 5 minutes\n\n      return result\n    } catch (error) {\n      logger.error(`Failed to get EDDN analytics (${type}):`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Get time-series data with trend analysis\n   */\n  async getTimeSeriesData (collection, interval, startDate, endDate, filters = {}) {\n    try {\n      const cacheKey = `timeseries_${collection}_${interval}_${startDate.getTime()}_${endDate.getTime()}_${JSON.stringify(filters)}`\n\n      const cachedResult = await this.getCachedResult(cacheKey)\n      if (cachedResult) {\n        return cachedResult\n      }\n\n      let result\n\n      switch (collection) {\n        case 'market_data':\n          result = await this.timeSeriesHandler.aggregateMarketData(\n            filters.commodity, interval, startDate, endDate, filters.system\n          )\n          break\n        case 'mining_sessions':\n          result = await this.timeSeriesHandler.aggregateMiningData(\n            interval, startDate, endDate, filters.commodity\n          )\n          break\n        case 'api_usage':\n          result = await this.timeSeriesHandler.aggregateAPIUsage(\n            interval, startDate, endDate\n          )\n          break\n        default:\n          throw new Error(`Time series not supported for collection: ${collection}`)\n      }\n\n      // Cache for 30 minutes\n      await this.setCachedResult(cacheKey, result, 30 * 60)\n\n      return result\n    } catch (error) {\n      logger.error(`Failed to get time series data for ${collection}:`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Perform database maintenance\n   */\n  async performMaintenance () {\n    try {\n      logger.info('Starting database maintenance...')\n\n      const results = {}\n\n      // Run archival process\n      results.archival = await this.archivalManager.executeArchivalProcess()\n\n      // Update index statistics\n      results.indexes = await this.indexManager.getIndexStats()\n\n      // Compact collections if needed\n      results.compaction = await this.performCompaction()\n\n      // Analyze query performance\n      results.performance = await this.analyzeQueryPerformance()\n\n      logger.info('Database maintenance completed:', results)\n      return results\n    } catch (error) {\n      logger.error('Database maintenance failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Get performance metrics\n   */\n  async getPerformanceMetrics () {\n    try {\n      const serverStatus = await this.db.admin().serverStatus()\n\n      return {\n        connections: serverStatus.connections,\n        operations: serverStatus.opcounters,\n        memory: serverStatus.mem,\n        locks: serverStatus.locks,\n        network: serverStatus.network,\n        uptime: serverStatus.uptime,\n        version: serverStatus.version\n      }\n    } catch (error) {\n      logger.warn('Failed to get performance metrics:', error)\n      return { error: error.message }\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStorageStatistics () {\n    try {\n      const dbStats = await this.db.stats()\n\n      return {\n        storageSize: dbStats.storageSize,\n        dataSize: dbStats.dataSize,\n        indexSize: dbStats.indexSize,\n        fileSize: dbStats.fileSize,\n        collections: dbStats.collections,\n        indexes: dbStats.indexes,\n        avgObjSize: dbStats.avgObjSize\n      }\n    } catch (error) {\n      logger.warn('Failed to get storage statistics:', error)\n      return { error: error.message }\n    }\n  }\n\n  /**\n   * Perform collection compaction\n   */\n  async performCompaction () {\n    const collections = ['market_data', 'mining_locations', 'eddn_messages']\n    const results = {}\n\n    for (const collectionName of collections) {\n      try {\n        const collection = this.db.getCollection(collectionName)\n        const statsBefore = await collection.stats()\n\n        // Run compaction (note: this might take time and should be done during low usage)\n        await this.db.runCommand({ compact: collectionName })\n\n        const statsAfter = await collection.stats()\n\n        results[collectionName] = {\n          sizeBefore: statsBefore.storageSize,\n          sizeAfter: statsAfter.storageSize,\n          savedBytes: statsBefore.storageSize - statsAfter.storageSize\n        }\n      } catch (error) {\n        results[collectionName] = { error: error.message }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Analyze query performance\n   */\n  async analyzeQueryPerformance () {\n    try {\n      // Get slow operations\n      const currentOps = await this.db.admin().currentOp({\n        active: true,\n        secs_running: { $gte: 1 }\n      })\n\n      return {\n        slowOperations: currentOps.inprog.length,\n        operations: currentOps.inprog.map(op => ({\n          opid: op.opid,\n          op: op.op,\n          ns: op.ns,\n          duration: op.secs_running,\n          command: op.command\n        }))\n      }\n    } catch (error) {\n      return { error: error.message }\n    }\n  }\n\n  /**\n   * Schedule archival process to run daily\n   */\n  scheduleArchivalProcess () {\n    // Run at 2 AM daily\n    const now = new Date()\n    const next2AM = new Date()\n    next2AM.setHours(2, 0, 0, 0)\n\n    if (next2AM <= now) {\n      next2AM.setDate(next2AM.getDate() + 1)\n    }\n\n    const timeUntilNext = next2AM.getTime() - now.getTime()\n\n    setTimeout(() => {\n      this.archivalManager.scheduleArchivalProcess(24) // Every 24 hours\n    }, timeUntilNext)\n\n    logger.info(`Archival process scheduled to start at ${next2AM.toISOString()}`)\n  }\n\n  /**\n   * Schedule index maintenance\n   */\n  scheduleIndexMaintenance () {\n    // Run weekly maintenance\n    setInterval(async () => {\n      try {\n        await this.performMaintenance()\n      } catch (error) {\n        logger.error('Scheduled maintenance failed:', error)\n      }\n    }, 7 * 24 * 60 * 60 * 1000) // 7 days\n  }\n\n  /**\n   * Simple cache implementation (in production, use Redis)\n   */\n  async getCachedResult (key) {\n    // This is a simple in-memory cache\n    // In production, replace with Redis\n    if (this.cache && this.cache[key] && this.cache[key].expires > Date.now()) {\n      return this.cache[key].data\n    }\n    return null\n  }\n\n  async setCachedResult (key, data, ttlSeconds) {\n    if (!this.cache) {\n      this.cache = {}\n    }\n\n    this.cache[key] = {\n      data,\n      expires: Date.now() + (ttlSeconds * 1000)\n    }\n\n    // Clean up expired cache entries periodically\n    if (Math.random() < 0.1) { // 10% chance\n      this.cleanupCache()\n    }\n  }\n\n  cleanupCache () {\n    if (!this.cache) return\n\n    const now = Date.now()\n    Object.keys(this.cache).forEach(key => {\n      if (this.cache[key].expires <= now) {\n        delete this.cache[key]\n      }\n    })\n  }\n\n  /**\n   * Health check for database features\n   */\n  async healthCheck () {\n    const health = {\n      status: 'healthy',\n      features: {},\n      timestamp: new Date().toISOString()\n    }\n\n    try {\n      // Check basic database connectivity\n      await this.db.admin().ping()\n      health.features.database = 'connected'\n    } catch (error) {\n      health.status = 'unhealthy'\n      health.features.database = 'disconnected'\n    }\n\n    try {\n      // Check if indexes exist\n      const stats = await this.indexManager.getIndexStats()\n      health.features.indexes = Object.keys(stats).length > 0 ? 'available' : 'missing'\n    } catch (error) {\n      health.features.indexes = 'error'\n    }\n\n    try {\n      // Check archival manager\n      const archivalStats = await this.archivalManager.getArchivalStatistics()\n      health.features.archival = 'configured'\n    } catch (error) {\n      health.features.archival = 'error'\n    }\n\n    health.features.timeSeriesHandler = 'ready'\n    health.features.aggregationPipelines = 'ready'\n\n    return health\n  }\n}\n\nmodule.exports = EnhancedDatabaseManager\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\mongoIndexes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\database\\timeSeriesHandler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\middleware\\monitoringMiddleware.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":93,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":93,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2373,2472],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2632,2839],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":210,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":210,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5607,5664],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":226,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":226,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6121,6173],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"n/handle-callback-err","severity":2,"message":"Expected error to be handled.","line":253,"column":21,"nodeType":"FunctionExpression","messageId":"expected","endLine":261,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Monitoring Middleware\n * Express middleware for automatic error tracking, performance monitoring, and request logging\n */\n\nconst ErrorTrackingService = require('../services/errorTrackingService')\nconst PerformanceMetricsService = require('../services/performanceMetricsService')\n\nclass MonitoringMiddleware {\n  constructor () {\n    this.errorTracking = new ErrorTrackingService()\n    this.performanceMetrics = new PerformanceMetricsService()\n    this.initialized = false\n  }\n\n  /**\n     * Initialize monitoring middleware\n     */\n  async initialize () {\n    if (this.initialized) return\n\n    await this.errorTracking.initialize()\n    this.performanceMetrics.startCollection()\n    this.initialized = true\n  }\n\n  /**\n     * Request timing middleware\n     */\n  requestTiming () {\n    return (req, res, next) => {\n      req.startTime = Date.now()\n\n      // Add request ID for tracking\n      req.requestId = this.generateRequestId()\n\n      // Track request start\n      res.on('finish', () => {\n        const responseTime = Date.now() - req.startTime\n        const size = parseInt(res.get('Content-Length') || '0')\n\n        this.performanceMetrics.recordRequest(\n          req.route?.path || req.path,\n          req.method,\n          res.statusCode,\n          responseTime,\n          size\n        )\n      })\n\n      next()\n    }\n  }\n\n  /**\n     * Error tracking middleware\n     */\n  errorTracking () {\n    return async (error, req, res, next) => {\n      // Track the error\n      const errorId = await this.errorTracking.trackError(error, {\n        type: this.categorizeRequestError(error, req),\n        severity: this.determineSeverity(error, res.statusCode),\n        endpoint: req.path,\n        method: req.method,\n        userAgent: req.get('User-Agent'),\n        ipAddress: req.ip || req.connection.remoteAddress,\n        requestId: req.requestId,\n        context: {\n          query: req.query,\n          params: req.params,\n          headers: this.sanitizeHeaders(req.headers),\n          body: this.sanitizeBody(req.body)\n        }\n      })\n\n      // Add error ID to response headers\n      res.set('X-Error-ID', errorId)\n\n      // Continue with default error handling\n      next(error)\n    }\n  }\n\n  /**\n     * Request logging middleware\n     */\n  requestLogging () {\n    return (req, res, next) => {\n      const startTime = Date.now()\n\n      // Log request start\n      console.log(`${new Date().toISOString()} [${req.requestId}] ${req.method} ${req.path} - ${req.ip}`)\n\n      res.on('finish', () => {\n        const responseTime = Date.now() - startTime\n        const logLevel = res.statusCode >= 400 ? 'ERROR' : 'INFO'\n\n        console.log(\n                    `${new Date().toISOString()} [${req.requestId}] ${logLevel}: ` +\n                    `${req.method} ${req.path} - ${res.statusCode} - ${responseTime}ms - ${req.ip}`\n        )\n      })\n\n      next()\n    }\n  }\n\n  /**\n     * Rate limiting monitoring middleware\n     */\n  rateLimitMonitoring () {\n    return (req, res, next) => {\n      // Check if rate limited\n      if (res.statusCode === 429) {\n        this.errorTracking.trackError(new Error('Rate limit exceeded'), {\n          type: 'RATE_LIMIT_ERROR',\n          severity: 'low',\n          endpoint: req.path,\n          method: req.method,\n          ipAddress: req.ip,\n          userAgent: req.get('User-Agent'),\n          requestId: req.requestId\n        })\n      }\n\n      next()\n    }\n  }\n\n  /**\n     * Security monitoring middleware\n     */\n  securityMonitoring () {\n    return (req, res, next) => {\n      // Monitor for suspicious patterns\n      const suspiciousPatterns = [\n        /(<script.*?>)/i,\n        /(union.*select)/i,\n        /(drop.*table)/i,\n        /(exec.*xp_)/i,\n        /(\\.\\.)/,\n        /(\\/etc\\/passwd)/i\n      ]\n\n      const checkValue = (value) => {\n        if (typeof value === 'string') {\n          return suspiciousPatterns.some(pattern => pattern.test(value))\n        }\n        return false\n      }\n\n      let suspicious = false\n      const suspiciousData = []\n\n      // Check query parameters\n      for (const [key, value] of Object.entries(req.query || {})) {\n        if (checkValue(value)) {\n          suspicious = true\n          suspiciousData.push({ type: 'query', key, value })\n        }\n      }\n\n      // Check request body\n      if (req.body && typeof req.body === 'object') {\n        for (const [key, value] of Object.entries(req.body)) {\n          if (checkValue(value)) {\n            suspicious = true\n            suspiciousData.push({ type: 'body', key, value })\n          }\n        }\n      }\n\n      // Check headers for suspicious values\n      const suspiciousHeaders = req.get('User-Agent')\n      if (suspiciousHeaders && checkValue(suspiciousHeaders)) {\n        suspicious = true\n        suspiciousData.push({ type: 'header', key: 'User-Agent', value: suspiciousHeaders })\n      }\n\n      if (suspicious) {\n        this.errorTracking.trackError(new Error('Suspicious request detected'), {\n          type: 'SECURITY_ALERT',\n          severity: 'medium',\n          endpoint: req.path,\n          method: req.method,\n          ipAddress: req.ip,\n          userAgent: req.get('User-Agent'),\n          requestId: req.requestId,\n          details: {\n            suspiciousData,\n            fullUrl: req.originalUrl\n          }\n        })\n      }\n\n      next()\n    }\n  }\n\n  /**\n     * API usage monitoring middleware\n     */\n  apiUsageMonitoring () {\n    return (req, res, next) => {\n      // Track API key usage if present\n      const apiKey = req.get('X-API-Key') || req.query.api_key\n      if (apiKey) {\n        // Would track API key usage here\n        console.log(`API Key used: ${apiKey.substring(0, 8)}...`)\n      }\n\n      // Track endpoint usage patterns\n      res.on('finish', () => {\n        const usageData = {\n          endpoint: req.path,\n          method: req.method,\n          statusCode: res.statusCode,\n          timestamp: Date.now(),\n          apiKey: apiKey ? apiKey.substring(0, 8) + '...' : null,\n          userAgent: req.get('User-Agent'),\n          ipAddress: req.ip\n        }\n\n        // Store usage data (would typically go to database)\n        console.log('API Usage:', JSON.stringify(usageData))\n      })\n\n      next()\n    }\n  }\n\n  /**\n     * Categorize request errors\n     */\n  categorizeRequestError (error, _req) {\n    const message = error.message.toLowerCase()\n\n    if (message.includes('validation')) return 'VALIDATION_ERROR'\n    if (message.includes('authentication') || message.includes('unauthorized')) return 'AUTHENTICATION_ERROR'\n    if (message.includes('permission') || message.includes('forbidden')) return 'PERMISSION_ERROR'\n    if (message.includes('not found') || message.includes('404')) return 'NOT_FOUND_ERROR'\n    if (message.includes('timeout')) return 'TIMEOUT_ERROR'\n    if (message.includes('database') || message.includes('connection')) return 'DATABASE_ERROR'\n    if (message.includes('rate limit')) return 'RATE_LIMIT_ERROR'\n\n    return 'API_ERROR'\n  }\n\n  /**\n     * Determine error severity based on error and status code\n     */\n  determineSeverity (error, statusCode) {\n    if (statusCode >= 500) return 'high'\n    if (statusCode === 401 || statusCode === 403) return 'medium'\n    if (statusCode === 404) return 'low'\n    if (statusCode === 429) return 'low'\n    if (statusCode >= 400) return 'medium'\n\n    return 'low'\n  }\n\n  /**\n     * Sanitize headers for logging\n     */\n  sanitizeHeaders (headers) {\n    const sanitized = { ...headers }\n\n    // Remove sensitive headers\n    const sensitiveHeaders = [\n      'authorization',\n      'cookie',\n      'x-api-key',\n      'x-auth-token'\n    ]\n\n    sensitiveHeaders.forEach(header => {\n      if (sanitized[header]) {\n        sanitized[header] = '[REDACTED]'\n      }\n    })\n\n    return sanitized\n  }\n\n  /**\n     * Sanitize request body for logging\n     */\n  sanitizeBody (body) {\n    if (!body || typeof body !== 'object') return body\n\n    const sanitized = { ...body }\n\n    // Remove sensitive fields\n    const sensitiveFields = [\n      'password',\n      'token',\n      'secret',\n      'key',\n      'apiKey',\n      'authToken'\n    ]\n\n    const sanitizeObject = (obj) => {\n      if (typeof obj !== 'object' || obj === null) return obj\n\n      const result = {}\n      for (const [key, value] of Object.entries(obj)) {\n        if (sensitiveFields.some(field => key.toLowerCase().includes(field.toLowerCase()))) {\n          result[key] = '[REDACTED]'\n        } else if (typeof value === 'object') {\n          result[key] = sanitizeObject(value)\n        } else {\n          result[key] = value\n        }\n      }\n      return result\n    }\n\n    return sanitizeObject(sanitized)\n  }\n\n  /**\n     * Generate unique request ID\n     */\n  generateRequestId () {\n    return `req_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`\n  }\n\n  /**\n     * Get combined middleware stack\n     */\n  getAllMiddleware () {\n    return [\n      this.requestTiming(),\n      this.requestLogging(),\n      this.securityMonitoring(),\n      this.apiUsageMonitoring(),\n      this.rateLimitMonitoring()\n    ]\n  }\n\n  /**\n     * Get error handling middleware\n     */\n  getErrorMiddleware () {\n    return this.errorTracking()\n  }\n\n  /**\n     * Cleanup resources\n     */\n  async cleanup () {\n    if (this.errorTracking) {\n      this.errorTracking.cleanup()\n    }\n    if (this.performanceMetrics) {\n      this.performanceMetrics.cleanup()\n    }\n  }\n}\n\nmodule.exports = MonitoringMiddleware\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\commodities.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\mining.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\monitoring.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":768,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":768,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[20254,20307],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Monitoring Routes\n * Comprehensive monitoring endpoints for health checks, metrics, errors, and alerts\n */\n\nconst express = require('express')\nconst router = express.Router()\nconst HealthCheckService = require('../services/healthCheckService')\nconst PerformanceMetricsService = require('../services/performanceMetricsService')\nconst ErrorTrackingService = require('../services/errorTrackingService')\nconst AlertingSystem = require('../services/alertingSystem')\n\n// Initialize services\nconst healthCheck = new HealthCheckService()\nconst performanceMetrics = new PerformanceMetricsService()\nconst errorTracking = new ErrorTrackingService()\nconst alerting = new AlertingSystem();\n\n// Initialize services\n(async () => {\n  await healthCheck.initialize?.()\n  await errorTracking.initialize()\n  await alerting.initialize()\n  performanceMetrics.startCollection()\n})()\n\n// Middleware to track request metrics\nrouter.use((req, res, next) => {\n  const startTime = Date.now()\n\n  res.on('finish', () => {\n    const responseTime = Date.now() - startTime\n    const size = parseInt(res.get('Content-Length') || '0')\n\n    performanceMetrics.recordRequest(\n      req.route?.path || req.path,\n      req.method,\n      res.statusCode,\n      responseTime,\n      size\n    )\n  })\n\n  next()\n})\n\n/**\n * @swagger\n * /monitoring/health:\n *   get:\n *     summary: Get comprehensive health status\n *     description: Returns detailed health information for all system components\n *     tags:\n *       - Monitoring\n *     responses:\n *       200:\n *         description: Health check results\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 status:\n *                   type: string\n *                   enum: [healthy, degraded, unhealthy]\n *                 timestamp:\n *                   type: string\n *                   format: date-time\n *                 uptime:\n *                   type: object\n *                 checks:\n *                   type: object\n *                 system:\n *                   type: object\n */\nrouter.get('/health', async (req, res) => {\n  try {\n    const healthStatus = await healthCheck.performHealthCheck()\n\n    const statusCode = healthStatus.status === 'healthy'\n      ? 200\n      : healthStatus.status === 'degraded' ? 200 : 503\n\n    res.status(statusCode).json({\n      success: true,\n      data: healthStatus,\n      metadata: {\n        source: 'health_check',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'HEALTH_CHECK_ERROR',\n      endpoint: '/monitoring/health',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'HEALTH_CHECK_FAILED',\n      message: 'Health check failed',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/health/history:\n *   get:\n *     summary: Get health check history\n *     description: Returns historical health check data\n *     tags:\n *       - Monitoring\n */\nrouter.get('/health/history', async (req, res) => {\n  try {\n    const history = healthCheck.getHealthHistory()\n\n    res.json({\n      success: true,\n      data: {\n        history,\n        totalEntries: history.length\n      },\n      metadata: {\n        source: 'health_history',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'HEALTH_HISTORY_ERROR',\n      endpoint: '/monitoring/health/history',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'HEALTH_HISTORY_FAILED',\n      message: 'Failed to retrieve health history',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/metrics:\n *   get:\n *     summary: Get performance metrics\n *     description: Returns comprehensive performance metrics and statistics\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: query\n *         name: timeRange\n *         schema:\n *           type: string\n *           enum: [1h, 6h, 24h, 7d]\n *           default: 1h\n *         description: Time range for metrics\n *       - in: query\n *         name: format\n *         schema:\n *           type: string\n *           enum: [json, prometheus]\n *           default: json\n *         description: Response format\n */\nrouter.get('/metrics', async (req, res) => {\n  try {\n    const timeRange = req.query.timeRange || '1h'\n    const format = req.query.format || 'json'\n\n    if (format === 'prometheus') {\n      const metricsData = performanceMetrics.exportMetrics('prometheus')\n      res.set('Content-Type', 'text/plain')\n      res.send(metricsData)\n      return\n    }\n\n    const report = performanceMetrics.getPerformanceReport(timeRange)\n\n    res.json({\n      success: true,\n      data: report,\n      metadata: {\n        source: 'performance_metrics',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'METRICS_ERROR',\n      endpoint: '/monitoring/metrics',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'METRICS_FAILED',\n      message: 'Failed to retrieve metrics',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/errors:\n *   get:\n *     summary: Get error statistics\n *     description: Returns comprehensive error tracking statistics\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: query\n *         name: timeRange\n *         schema:\n *           type: string\n *           enum: [1h, 6h, 24h, 7d]\n *           default: 24h\n *         description: Time range for error statistics\n *       - in: query\n *         name: severity\n *         schema:\n *           type: string\n *           enum: [critical, high, medium, low]\n *         description: Filter by error severity\n *       - in: query\n *         name: type\n *         schema:\n *           type: string\n *         description: Filter by error type\n */\nrouter.get('/errors', async (req, res) => {\n  try {\n    const timeRange = req.query.timeRange || '24h'\n    const errorStats = errorTracking.getErrorStatistics(timeRange)\n\n    // Apply filters if provided\n    if (req.query.severity || req.query.type) {\n      const filters = {}\n      if (req.query.severity) filters.severity = req.query.severity\n      if (req.query.type) filters.type = req.query.type\n\n      errorStats.filteredErrors = errorTracking.searchErrors(filters)\n    }\n\n    res.json({\n      success: true,\n      data: errorStats,\n      metadata: {\n        source: 'error_tracking',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ERROR_STATS_ERROR',\n      endpoint: '/monitoring/errors',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ERROR_STATS_FAILED',\n      message: 'Failed to retrieve error statistics',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/errors/{errorId}:\n *   get:\n *     summary: Get specific error details\n *     description: Returns detailed information about a specific error\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: path\n *         name: errorId\n *         required: true\n *         schema:\n *           type: string\n *         description: Error ID\n */\nrouter.get('/errors/:errorId', async (req, res) => {\n  try {\n    const errorDetails = errorTracking.getErrorDetails(req.params.errorId)\n\n    if (!errorDetails) {\n      return res.status(404).json({\n        success: false,\n        error: 'ERROR_NOT_FOUND',\n        message: 'Error not found',\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    res.json({\n      success: true,\n      data: errorDetails,\n      metadata: {\n        source: 'error_tracking',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ERROR_DETAIL_ERROR',\n      endpoint: `/monitoring/errors/${req.params.errorId}`,\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ERROR_DETAIL_FAILED',\n      message: 'Failed to retrieve error details',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/errors/{errorId}/resolve:\n *   post:\n *     summary: Mark error as resolved\n *     description: Mark a specific error as resolved with optional resolution note\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: path\n *         name: errorId\n *         required: true\n *         schema:\n *           type: string\n *         description: Error ID\n *     requestBody:\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               resolution:\n *                 type: string\n *                 description: Resolution note\n *               resolvedBy:\n *                 type: string\n *                 description: Who resolved the error\n */\nrouter.post('/errors/:errorId/resolve', async (req, res) => {\n  try {\n    const { resolution = '', resolvedBy = 'user' } = req.body\n    const success = errorTracking.resolveError(req.params.errorId, resolution)\n\n    if (!success) {\n      return res.status(404).json({\n        success: false,\n        error: 'ERROR_NOT_FOUND',\n        message: 'Error not found or already resolved',\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    res.json({\n      success: true,\n      data: {\n        errorId: req.params.errorId,\n        resolved: true,\n        resolution,\n        resolvedBy,\n        resolvedAt: new Date().toISOString()\n      },\n      metadata: {\n        source: 'error_tracking',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ERROR_RESOLVE_ERROR',\n      endpoint: `/monitoring/errors/${req.params.errorId}/resolve`,\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ERROR_RESOLVE_FAILED',\n      message: 'Failed to resolve error',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/alerts:\n *   get:\n *     summary: Get alerts\n *     description: Returns active alerts and alert statistics\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: query\n *         name: status\n *         schema:\n *           type: string\n *           enum: [active, resolved, all]\n *           default: active\n *         description: Filter alerts by status\n *       - in: query\n *         name: severity\n *         schema:\n *           type: string\n *           enum: [critical, high, warning, medium, low]\n *         description: Filter by alert severity\n */\nrouter.get('/alerts', async (req, res) => {\n  try {\n    const status = req.query.status || 'active'\n    let alerts\n\n    if (status === 'active') {\n      alerts = alerting.getActiveAlerts()\n    } else {\n      // Would implement getting all alerts or resolved alerts\n      alerts = alerting.getActiveAlerts()\n    }\n\n    // Apply severity filter if provided\n    if (req.query.severity) {\n      alerts = alerts.filter(alert => alert.severity === req.query.severity)\n    }\n\n    const statistics = alerting.getAlertStatistics()\n\n    res.json({\n      success: true,\n      data: {\n        alerts,\n        statistics,\n        filters: {\n          status: req.query.status,\n          severity: req.query.severity\n        }\n      },\n      metadata: {\n        source: 'alerting_system',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ALERTS_ERROR',\n      endpoint: '/monitoring/alerts',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ALERTS_FAILED',\n      message: 'Failed to retrieve alerts',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/alerts/{alertId}/acknowledge:\n *   post:\n *     summary: Acknowledge alert\n *     description: Mark an alert as acknowledged\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: path\n *         name: alertId\n *         required: true\n *         schema:\n *           type: string\n *         description: Alert ID\n *     requestBody:\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               acknowledgedBy:\n *                 type: string\n *                 description: Who acknowledged the alert\n */\nrouter.post('/alerts/:alertId/acknowledge', async (req, res) => {\n  try {\n    const { acknowledgedBy = 'user' } = req.body\n    const success = alerting.acknowledgeAlert(req.params.alertId, acknowledgedBy)\n\n    if (!success) {\n      return res.status(404).json({\n        success: false,\n        error: 'ALERT_NOT_FOUND',\n        message: 'Alert not found or already acknowledged',\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    res.json({\n      success: true,\n      data: {\n        alertId: req.params.alertId,\n        acknowledged: true,\n        acknowledgedBy,\n        acknowledgedAt: new Date().toISOString()\n      },\n      metadata: {\n        source: 'alerting_system',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ALERT_ACKNOWLEDGE_ERROR',\n      endpoint: `/monitoring/alerts/${req.params.alertId}/acknowledge`,\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ALERT_ACKNOWLEDGE_FAILED',\n      message: 'Failed to acknowledge alert',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/alerts/{alertId}/resolve:\n *   post:\n *     summary: Resolve alert\n *     description: Mark an alert as resolved\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: path\n *         name: alertId\n *         required: true\n *         schema:\n *           type: string\n *         description: Alert ID\n *     requestBody:\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               resolvedBy:\n *                 type: string\n *                 description: Who resolved the alert\n *               resolution:\n *                 type: string\n *                 description: Resolution note\n */\nrouter.post('/alerts/:alertId/resolve', async (req, res) => {\n  try {\n    const { resolvedBy = 'user', resolution = '' } = req.body\n    const success = alerting.resolveAlert(req.params.alertId, resolvedBy, resolution)\n\n    if (!success) {\n      return res.status(404).json({\n        success: false,\n        error: 'ALERT_NOT_FOUND',\n        message: 'Alert not found or already resolved',\n        timestamp: new Date().toISOString()\n      })\n    }\n\n    res.json({\n      success: true,\n      data: {\n        alertId: req.params.alertId,\n        resolved: true,\n        resolvedBy,\n        resolution,\n        resolvedAt: new Date().toISOString()\n      },\n      metadata: {\n        source: 'alerting_system',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ALERT_RESOLVE_ERROR',\n      endpoint: `/monitoring/alerts/${req.params.alertId}/resolve`,\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ALERT_RESOLVE_FAILED',\n      message: 'Failed to resolve alert',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/alerts/test/{channel}:\n *   post:\n *     summary: Test notification channel\n *     description: Send a test alert to verify notification channel configuration\n *     tags:\n *       - Monitoring\n *     parameters:\n *       - in: path\n *         name: channel\n *         required: true\n *         schema:\n *           type: string\n *         description: Notification channel name\n */\nrouter.post('/alerts/test/:channel', async (req, res) => {\n  try {\n    const channelName = req.params.channel\n    const success = await alerting.testNotificationChannel(channelName)\n\n    res.json({\n      success: true,\n      data: {\n        channel: channelName,\n        testResult: success,\n        message: success ? 'Test notification sent successfully' : 'Test notification failed'\n      },\n      metadata: {\n        source: 'alerting_system',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'ALERT_TEST_ERROR',\n      endpoint: `/monitoring/alerts/test/${req.params.channel}`,\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'ALERT_TEST_FAILED',\n      message: error.message,\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n/**\n * @swagger\n * /monitoring/dashboard:\n *   get:\n *     summary: Get monitoring dashboard data\n *     description: Returns comprehensive monitoring dashboard with all key metrics\n *     tags:\n *       - Monitoring\n */\nrouter.get('/dashboard', async (req, res) => {\n  try {\n    const [\n      healthStatus,\n      performanceReport,\n      errorStats,\n      alertStats\n    ] = await Promise.all([\n      healthCheck.performHealthCheck(),\n      Promise.resolve(performanceMetrics.getPerformanceReport('1h')),\n      Promise.resolve(errorTracking.getErrorStatistics('24h')),\n      Promise.resolve(alerting.getAlertStatistics('24h'))\n    ])\n\n    const dashboard = {\n      overview: {\n        systemHealth: healthStatus.status,\n        activeAlerts: alertStats.active,\n        errorRate: errorStats.summary.errorRate,\n        averageResponseTime: performanceReport.summary.averageResponseTime,\n        uptime: healthStatus.uptime,\n        lastUpdated: new Date().toISOString()\n      },\n      health: {\n        status: healthStatus.status,\n        checks: healthStatus.checks,\n        summary: healthStatus.summary\n      },\n      performance: {\n        summary: performanceReport.summary,\n        system: performanceReport.system,\n        trends: performanceReport.trends\n      },\n      errors: {\n        summary: errorStats.summary,\n        topErrors: errorStats.topErrors.slice(0, 5),\n        patterns: errorStats.patterns.slice(0, 5)\n      },\n      alerts: {\n        active: alertStats.active,\n        total: alertStats.total,\n        bySeverity: alertStats.bySeverity,\n        recentAlerts: alerting.getActiveAlerts().slice(0, 5)\n      }\n    }\n\n    res.json({\n      success: true,\n      data: dashboard,\n      metadata: {\n        source: 'monitoring_dashboard',\n        processingTime: Date.now() - req.startTime,\n        timestamp: new Date().toISOString()\n      }\n    })\n  } catch (error) {\n    await errorTracking.trackError(error, {\n      type: 'DASHBOARD_ERROR',\n      endpoint: '/monitoring/dashboard',\n      method: req.method\n    })\n\n    res.status(500).json({\n      success: false,\n      error: 'DASHBOARD_FAILED',\n      message: 'Failed to retrieve dashboard data',\n      timestamp: new Date().toISOString()\n    })\n  }\n})\n\n// Setup real-time monitoring integrations\nperformanceMetrics.on('alert', async (alert) => {\n  await alerting.checkAlertRules(alert, 'performance')\n})\n\nerrorTracking.on('error', async (error) => {\n  await alerting.checkAlertRules(error, 'error')\n})\n\n// Periodic health checks and alerting\nsetInterval(async () => {\n  try {\n    const healthStatus = await healthCheck.performHealthCheck()\n    await alerting.checkAlertRules(healthStatus, 'health')\n  } catch (error) {\n    console.error('Periodic health check failed:', error)\n  }\n}, 60000) // Every minute\n\n// Cleanup old data periodically\nsetInterval(() => {\n  errorTracking.clearOldErrors()\n  alerting.cleanupOldAlerts()\n}, 24 * 60 * 60 * 1000) // Daily cleanup\n\n// Export services for external use\nrouter.healthCheck = healthCheck\nrouter.performanceMetrics = performanceMetrics\nrouter.errorTracking = errorTracking\nrouter.alerting = alerting\n\nmodule.exports = router\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\stats.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\status.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\routes\\systems.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\cacheManager.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":224,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":224,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unified Cache Manager\n * Integrates Redis and In-Memory caching with performance optimization\n */\n\nconst RedisCacheService = require('./redisCacheService')\nconst InMemoryCacheService = require('./inMemoryCacheService')\nconst CacheInvalidationManager = require('./cacheInvalidationManager')\nconst logger = require('./logger')\n\nclass CacheManager {\n  constructor (config = {}) {\n    this.config = {\n      redis: config.redis || {},\n      inMemory: config.inMemory || {},\n      strategy: config.strategy || 'hybrid', // 'redis-only', 'memory-only', 'hybrid'\n      performanceOptimization: config.performanceOptimization !== false\n    }\n\n    this.redisCache = null\n    this.inMemoryCache = null\n    this.invalidationManager = null\n\n    this.stats = {\n      totalRequests: 0,\n      redisHits: 0,\n      memoryHits: 0,\n      misses: 0,\n      errors: 0\n    }\n  }\n\n  /**\n   * Initialize cache manager\n   */\n  async initialize () {\n    try {\n      logger.info('Initializing Cache Manager...')\n\n      // Initialize in-memory cache (always available)\n      if (this.config.strategy === 'memory-only' || this.config.strategy === 'hybrid') {\n        this.inMemoryCache = new InMemoryCacheService(this.config.inMemory)\n        logger.info('In-memory cache initialized')\n      }\n\n      // Initialize Redis cache (if configured)\n      if (this.config.strategy === 'redis-only' || this.config.strategy === 'hybrid') {\n        try {\n          this.redisCache = new RedisCacheService(this.config.redis)\n          await this.redisCache.initialize()\n          logger.info('Redis cache initialized')\n        } catch (error) {\n          logger.warn('Redis cache initialization failed, falling back to memory-only:', error)\n\n          if (this.config.strategy === 'redis-only') {\n            throw new Error('Redis cache required but initialization failed')\n          }\n\n          // Fall back to memory-only for hybrid strategy\n          this.config.strategy = 'memory-only'\n        }\n      }\n\n      // Initialize invalidation manager\n      this.invalidationManager = new CacheInvalidationManager(\n        this.redisCache,\n        this.inMemoryCache\n      )\n\n      // Set up scheduled invalidation\n      this.invalidationManager.setupScheduledInvalidation()\n\n      logger.info(`Cache Manager initialized with strategy: ${this.config.strategy}`)\n\n      return {\n        status: 'initialized',\n        strategy: this.config.strategy,\n        redis: !!this.redisCache,\n        inMemory: !!this.inMemoryCache\n      }\n    } catch (error) {\n      logger.error('Cache Manager initialization failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Get data from cache with fallback strategy\n   */\n  async get (key, options = {}) {\n    this.stats.totalRequests++\n\n    try {\n      // Try in-memory cache first (fastest)\n      if (this.inMemoryCache && (this.config.strategy === 'hybrid' || this.config.strategy === 'memory-only')) {\n        const memoryValue = this.inMemoryCache.get(key)\n        if (memoryValue !== null) {\n          this.stats.memoryHits++\n          return memoryValue\n        }\n      }\n\n      // Try Redis cache second\n      if (this.redisCache && (this.config.strategy === 'hybrid' || this.config.strategy === 'redis-only')) {\n        const redisValue = await this.redisCache.get(key)\n        if (redisValue !== null) {\n          this.stats.redisHits++\n\n          // Populate in-memory cache for future requests (if hybrid)\n          if (this.config.strategy === 'hybrid' && this.inMemoryCache) {\n            const ttl = options.memoryTTL || 60 // Default 1 minute for memory cache\n            this.inMemoryCache.set(key, redisValue, ttl)\n          }\n\n          return redisValue\n        }\n      }\n\n      this.stats.misses++\n      return null\n    } catch (error) {\n      logger.error(`Cache GET error for key ${key}:`, error)\n      this.stats.errors++\n      return null\n    }\n  }\n\n  /**\n   * Set data in cache with multi-tier strategy\n   */\n  async set (key, value, options = {}) {\n    const {\n      redisTTL = 300, // 5 minutes default for Redis\n      memoryTTL = 60, // 1 minute default for memory\n      strategy = null // Override default strategy\n    } = options\n\n    const useStrategy = strategy || this.config.strategy\n    let redisSuccess = false\n    let memorySuccess = false\n\n    try {\n      // Set in Redis\n      if (this.redisCache && (useStrategy === 'hybrid' || useStrategy === 'redis-only')) {\n        redisSuccess = await this.redisCache.set(key, value, redisTTL)\n      }\n\n      // Set in memory\n      if (this.inMemoryCache && (useStrategy === 'hybrid' || useStrategy === 'memory-only')) {\n        memorySuccess = this.inMemoryCache.set(key, value, memoryTTL)\n      }\n\n      return redisSuccess || memorySuccess\n    } catch (error) {\n      logger.error(`Cache SET error for key ${key}:`, error)\n      this.stats.errors++\n      return false\n    }\n  }\n\n  /**\n   * Delete from all cache tiers\n   */\n  async del (key) {\n    let deleted = false\n\n    try {\n      // Delete from Redis\n      if (this.redisCache) {\n        const redisDeleted = await this.redisCache.del(key)\n        deleted = deleted || redisDeleted\n      }\n\n      // Delete from memory\n      if (this.inMemoryCache) {\n        const memoryDeleted = this.inMemoryCache.delete(key)\n        deleted = deleted || memoryDeleted\n      }\n\n      return deleted\n    } catch (error) {\n      logger.error(`Cache DEL error for key ${key}:`, error)\n      this.stats.errors++\n      return false\n    }\n  }\n\n  /**\n   * Cache market data with optimized strategy\n   */\n  async cacheMarketData (type, key, data, system = null) {\n    const options = this.getMarketDataCacheOptions(type)\n\n    // Use Redis for market data (larger, less frequently accessed)\n    if (this.redisCache) {\n      return await this.redisCache.cacheMarketData(type, key, data, system)\n    } else if (this.inMemoryCache) {\n      // Fallback to memory cache with shorter TTL\n      const cacheKey = this.buildMarketCacheKey(type, key, system)\n      return this.inMemoryCache.set(cacheKey, data, options.memoryTTL)\n    }\n\n    return false\n  }\n\n  /**\n   * Get market data with optimized retrieval\n   */\n  async getMarketData (type, key, system = null) {\n    if (this.redisCache) {\n      return await this.redisCache.getMarketData(type, key, system)\n    } else if (this.inMemoryCache) {\n      const cacheKey = this.buildMarketCacheKey(type, key, system)\n      return this.inMemoryCache.get(cacheKey)\n    }\n\n    return null\n  }\n\n  /**\n   * Cache statistics with memory-first strategy\n   */\n  async cacheStatistics (type, data, filters = {}) {\n    const options = this.getStatisticsCacheOptions(type)\n\n    // Statistics are cached in memory first for speed\n    if (this.inMemoryCache) {\n      this.inMemoryCache.cacheStatistics(type, data, filters)\n    }\n\n    // Also cache in Redis for persistence\n    if (this.redisCache) {\n      await this.redisCache.cacheStatistics(type, data, filters)\n    }\n\n    return true\n  }\n\n  /**\n   * Get statistics with memory-first lookup\n   */\n  async getStatistics (type, filters = {}) {\n    // Try memory first for statistics (faster access)\n    if (this.inMemoryCache) {\n      const memoryValue = this.inMemoryCache.getStatistics(type, filters)\n      if (memoryValue) {\n        this.stats.memoryHits++\n        return memoryValue\n      }\n    }\n\n    // Fallback to Redis\n    if (this.redisCache) {\n      const redisValue = await this.redisCache.getStatistics(type, filters)\n      if (redisValue) {\n        this.stats.redisHits++\n\n        // Populate memory cache\n        if (this.inMemoryCache) {\n          this.inMemoryCache.cacheStatistics(type, redisValue, filters)\n        }\n\n        return redisValue\n      }\n    }\n\n    this.stats.misses++\n    return null\n  }\n\n  /**\n   * Cache server metrics (memory-only for speed)\n   */\n  cacheServerMetrics (metrics) {\n    if (this.inMemoryCache) {\n      return this.inMemoryCache.cacheServerMetrics(metrics)\n    }\n    return false\n  }\n\n  /**\n   * Get server metrics\n   */\n  getServerMetrics () {\n    if (this.inMemoryCache) {\n      return this.inMemoryCache.getServerMetrics()\n    }\n    return null\n  }\n\n  /**\n   * Cache API response times\n   */\n  cacheAPIResponseTime (endpoint, method, duration) {\n    if (this.inMemoryCache) {\n      return this.inMemoryCache.cacheAPIResponseTime(endpoint, method, duration)\n    }\n    return false\n  }\n\n  /**\n   * Get API response times\n   */\n  getAPIResponseTimes (endpoint, method) {\n    if (this.inMemoryCache) {\n      return this.inMemoryCache.getAPIResponseTimes(endpoint, method)\n    }\n    return null\n  }\n\n  /**\n   * Invalidate cache\n   */\n  async invalidateCache (dataType, trigger, context = {}) {\n    if (this.invalidationManager) {\n      return await this.invalidationManager.invalidateCache(dataType, trigger, context)\n    }\n    return false\n  }\n\n  /**\n   * Get cache options for market data\n   */\n  getMarketDataCacheOptions (type) {\n    const options = {\n      commodity: { redisTTL: 300, memoryTTL: 60 }, // 5min Redis, 1min memory\n      routes: { redisTTL: 600, memoryTTL: 120 }, // 10min Redis, 2min memory\n      trends: { redisTTL: 1800, memoryTTL: 300 }, // 30min Redis, 5min memory\n      station: { redisTTL: 300, memoryTTL: 60 } // 5min Redis, 1min memory\n    }\n\n    return options[type] || { redisTTL: 300, memoryTTL: 60 }\n  }\n\n  /**\n   * Get cache options for statistics\n   */\n  getStatisticsCacheOptions (type) {\n    const options = {\n      global: { redisTTL: 600, memoryTTL: 60 }, // 10min Redis, 1min memory\n      eddn: { redisTTL: 120, memoryTTL: 30 }, // 2min Redis, 30sec memory\n      mining: { redisTTL: 1800, memoryTTL: 300 }, // 30min Redis, 5min memory\n      api_usage: { redisTTL: 300, memoryTTL: 60 }, // 5min Redis, 1min memory\n      websocket: { redisTTL: 60, memoryTTL: 30 } // 1min Redis, 30sec memory\n    }\n\n    return options[type] || { redisTTL: 300, memoryTTL: 60 }\n  }\n\n  /**\n   * Build market cache key\n   */\n  buildMarketCacheKey (type, key, system) {\n    const parts = ['market', type, key]\n    if (system) {\n      parts.push(system)\n    }\n    return parts.join(':')\n  }\n\n  /**\n   * Warm up cache with frequently accessed data\n   */\n  async warmupCache () {\n    logger.info('Starting cache warmup...')\n\n    try {\n      // Redis warmup\n      if (this.redisCache) {\n        await this.redisCache.warmupCache()\n      }\n\n      // Memory cache warmup with essential statistics\n      if (this.inMemoryCache) {\n        // Pre-load essential server metrics structure\n        this.inMemoryCache.cacheServerMetrics({\n          initialized: true,\n          startup_time: new Date().toISOString()\n        })\n      }\n\n      logger.info('Cache warmup completed')\n      return true\n    } catch (error) {\n      logger.error('Cache warmup failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Get comprehensive cache statistics\n   */\n  async getCacheStats () {\n    const stats = {\n      manager: { ...this.stats },\n      timestamp: new Date().toISOString()\n    }\n\n    // Get Redis stats\n    if (this.redisCache) {\n      stats.redis = this.redisCache.getCacheStats()\n    }\n\n    // Get memory stats\n    if (this.inMemoryCache) {\n      stats.inMemory = this.inMemoryCache.getStats()\n    }\n\n    // Calculate overall hit rate\n    const totalHits = this.stats.redisHits + this.stats.memoryHits\n    const totalRequests = this.stats.totalRequests\n    stats.manager.overallHitRate = totalRequests > 0\n      ? Math.round((totalHits / totalRequests) * 10000) / 100\n      : 0\n\n    return stats\n  }\n\n  /**\n   * Health check for entire cache system\n   */\n  async healthCheck () {\n    const health = {\n      status: 'healthy',\n      strategy: this.config.strategy,\n      components: {},\n      stats: await this.getCacheStats(),\n      timestamp: new Date().toISOString()\n    }\n\n    // Check Redis health\n    if (this.redisCache) {\n      const redisHealth = await this.redisCache.healthCheck()\n      health.components.redis = redisHealth\n      if (redisHealth.status !== 'healthy') {\n        health.status = 'degraded'\n      }\n    }\n\n    // Check memory cache health\n    if (this.inMemoryCache) {\n      const memoryHealth = this.inMemoryCache.healthCheck()\n      health.components.inMemory = memoryHealth\n      if (memoryHealth.status !== 'healthy') {\n        health.status = 'degraded'\n      }\n    }\n\n    // Check invalidation manager health\n    if (this.invalidationManager) {\n      const invalidationHealth = await this.invalidationManager.healthCheck()\n      health.components.invalidation = invalidationHealth\n      if (invalidationHealth.status !== 'healthy') {\n        health.status = 'degraded'\n      }\n    }\n\n    return health\n  }\n\n  /**\n   * Clear all caches\n   */\n  async clearAll () {\n    logger.info('Clearing all caches...')\n\n    let cleared = 0\n\n    if (this.redisCache) {\n      const redisCleared = await this.redisCache.clearCache()\n      if (redisCleared) cleared++\n    }\n\n    if (this.inMemoryCache) {\n      this.inMemoryCache.clear()\n      cleared++\n    }\n\n    // Reset stats\n    this.stats = {\n      totalRequests: 0,\n      redisHits: 0,\n      memoryHits: 0,\n      misses: 0,\n      errors: 0\n    }\n\n    logger.info(`Cleared ${cleared} cache layers`)\n    return cleared\n  }\n\n  /**\n   * Gracefully close cache connections\n   */\n  async close () {\n    logger.info('Closing Cache Manager...')\n\n    if (this.redisCache) {\n      await this.redisCache.close()\n    }\n\n    if (this.inMemoryCache) {\n      this.inMemoryCache.clear()\n    }\n\n    logger.info('Cache Manager closed')\n  }\n}\n\nmodule.exports = CacheManager\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\dataProcessor.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'timestamp' is assigned a value but never used.","line":41,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const logger = require('../services/logger')\n\nclass DataProcessor {\n  constructor (database) {\n    this.database = database\n    this.processingQueue = []\n    this.isProcessing = false\n    this.statistics = {\n      totalProcessed: 0,\n      miningReports: 0,\n      commodityUpdates: 0,\n      systemUpdates: 0,\n      errors: 0\n    }\n  }\n\n  async processEDDNMessage (data) {\n    try {\n      const schema = data.$schemaRef\n      const message = data.message\n\n      if (schema.includes('commodity')) {\n        await this.processCommodityMessage(message)\n        this.statistics.commodityUpdates++\n      } else if (schema.includes('journal')) {\n        await this.processJournalMessage(message)\n      }\n\n      this.statistics.totalProcessed++\n    } catch (error) {\n      logger.error('Error processing EDDN message:', error)\n      this.statistics.errors++\n    }\n  }\n\n  async processCommodityMessage (message) {\n    try {\n      // Extract station and system information\n      const stationName = message.stationName\n      const systemName = message.systemName\n      const timestamp = message.timestamp\n\n      // Store station if not exists\n      await this.storeStation({\n        name: stationName,\n        systemName,\n        stationType: message.stationType,\n        distanceFromStar: message.distFromStarLS,\n        hasMarket: true,\n        source: 'eddn'\n      })\n\n      // Store system if not exists\n      await this.storeSystem({\n        name: systemName,\n        coordinates: message.systemCoordinates,\n        source: 'eddn'\n      })\n\n      // Process commodities\n      if (message.commodities && Array.isArray(message.commodities)) {\n        for (const commodity of message.commodities) {\n          await this.database.insertCommodityPrice({\n            commodityName: commodity.name,\n            commodityId: commodity.id,\n            stationName,\n            systemName,\n            buyPrice: commodity.buyPrice || 0,\n            sellPrice: commodity.sellPrice || 0,\n            supply: commodity.stock || 0,\n            demand: commodity.demand || 0,\n            distanceFromStar: message.distFromStarLS,\n            stationType: message.stationType,\n            source: 'eddn'\n          })\n        }\n      }\n\n      logger.info(`Processed commodity data for ${stationName} in ${systemName}`)\n    } catch (error) {\n      logger.error('Error processing commodity message:', error)\n    }\n  }\n\n  async processJournalMessage (message) {\n    try {\n      const event = message.event\n\n      switch (event) {\n        case 'MiningRefined':\n          await this.processMiningRefined(message)\n          break\n\n        case 'ProspectedAsteroid':\n          await this.processProspectedAsteroid(message)\n          break\n\n        case 'AsteroidCracked':\n          await this.processAsteroidCracked(message)\n          break\n\n        case 'MarketSell':\n          await this.processMarketSell(message)\n          break\n\n        default:\n          // Log unknown mining-related events for future implementation\n          if (this.isMiningRelated(message)) {\n            logger.info(`Unknown mining event: ${event}`, { message })\n          }\n      }\n    } catch (error) {\n      logger.error(`Error processing journal event ${message.event}:`, error)\n    }\n  }\n\n  async processMiningRefined (message) {\n    await this.database.insertMiningReport({\n      commanderName: null, // EDDN anonymizes commander names\n      systemName: message.StarSystem,\n      bodyName: message.Body,\n      materialRefined: message.Type,\n      amount: 1,\n      source: 'eddn'\n    })\n\n    this.statistics.miningReports++\n    logger.info(`Mining refined: ${message.Type} in ${message.StarSystem}`)\n  }\n\n  async processProspectedAsteroid (message) {\n    // Store information about prospected asteroids\n    // This could be used to build a database of asteroid compositions\n    if (message.Materials && Array.isArray(message.Materials)) {\n      for (const material of message.Materials) {\n        // Could store prospect data for analysis\n        logger.debug(`Asteroid prospect: ${material.Name} (${material.Proportion}%) in ${message.StarSystem}`)\n      }\n    }\n  }\n\n  async processAsteroidCracked (message) {\n    // Log asteroid cracking events\n    logger.info(`Asteroid cracked in ${message.StarSystem} at ${message.Body}`)\n  }\n\n  async processMarketSell (message) {\n    // If it's a mining commodity being sold, track it\n    if (this.isMiningCommodity(message.Type)) {\n      logger.info(`Mining commodity sold: ${message.Count}x ${message.Type} for ${message.TotalSale} credits`)\n    }\n  }\n\n  async storeStation (stationData) {\n    try {\n      const sql = `\n        INSERT OR IGNORE INTO stations \n        (name, system_name, station_type, distance_from_star, has_market, source)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `\n\n      await this.database.runQuery(sql, [\n        stationData.name,\n        stationData.systemName,\n        stationData.stationType,\n        stationData.distanceFromStar,\n        stationData.hasMarket ? 1 : 0,\n        stationData.source\n      ])\n    } catch (error) {\n      logger.error('Error storing station:', error)\n    }\n  }\n\n  async storeSystem (systemData) {\n    try {\n      const sql = `\n        INSERT OR IGNORE INTO systems \n        (name, coordinates_x, coordinates_y, coordinates_z, source)\n        VALUES (?, ?, ?, ?, ?)\n      `\n\n      const coords = systemData.coordinates || {}\n\n      await this.database.runQuery(sql, [\n        systemData.name,\n        coords.x || null,\n        coords.y || null,\n        coords.z || null,\n        systemData.source\n      ])\n\n      this.statistics.systemUpdates++\n    } catch (error) {\n      logger.error('Error storing system:', error)\n    }\n  }\n\n  isMiningRelated (message) {\n    const miningEvents = [\n      'MiningRefined',\n      'ProspectedAsteroid',\n      'AsteroidCracked',\n      'LaunchSRV',\n      'DockSRV'\n    ]\n\n    return miningEvents.includes(message.event)\n  }\n\n  isMiningCommodity (commodityName) {\n    const miningCommodities = [\n      'Painite', 'Void Opals', 'Low Temperature Diamonds',\n      'Alexandrite', 'Benitoite', 'Grandidierite', 'Monazite',\n      'Musgravite', 'Rhodplumsite', 'Serendibite', 'Taaffeite',\n      'Tritium', 'Platinum', 'Osmium', 'Gold', 'Silver',\n      'Palladium', 'Bertrandite', 'Indite', 'Gallite',\n      'Praseodymium', 'Samarium', 'Bromellite'\n    ]\n\n    return miningCommodities.includes(commodityName)\n  }\n\n  async aggregateHourlyData () {\n    try {\n      // Aggregate mining reports by hour\n      const hourlyMining = await this.database.allQuery(`\n        SELECT \n          datetime(timestamp, 'start of hour') as hour,\n          material_refined,\n          COUNT(*) as count,\n          system_name\n        FROM mining_reports \n        WHERE timestamp > datetime('now', '-24 hours')\n        GROUP BY hour, material_refined, system_name\n        ORDER BY hour DESC\n      `)\n\n      // Aggregate commodity price changes\n      const priceChanges = await this.database.allQuery(`\n        SELECT \n          commodity_name,\n          COUNT(DISTINCT station_name) as stations_updated,\n          AVG(sell_price) as avg_sell_price,\n          MAX(sell_price) as max_sell_price,\n          datetime(last_updated, 'start of hour') as hour\n        FROM commodity_prices \n        WHERE last_updated > datetime('now', '-24 hours')\n          AND sell_price > 0\n        GROUP BY commodity_name, hour\n        ORDER BY hour DESC\n      `)\n\n      return {\n        hourlyMining,\n        priceChanges,\n        generatedAt: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Error aggregating hourly data:', error)\n      return null\n    }\n  }\n\n  async generateMiningHotspotAnalysis () {\n    try {\n      // Analyze mining reports to identify potential hotspots\n      const hotspotAnalysis = await this.database.allQuery(`\n        SELECT \n          system_name,\n          body_name,\n          material_refined,\n          COUNT(*) as mining_frequency,\n          COUNT(DISTINCT DATE(timestamp)) as active_days,\n          MIN(timestamp) as first_report,\n          MAX(timestamp) as last_report\n        FROM mining_reports \n        WHERE timestamp > datetime('now', '-30 days')\n        GROUP BY system_name, body_name, material_refined\n        HAVING mining_frequency >= 5\n        ORDER BY mining_frequency DESC\n      `)\n\n      // Group by system and material for hotspot detection\n      const systemHotspots = {}\n\n      for (const report of hotspotAnalysis) {\n        const key = `${report.system_name}_${report.material_refined}`\n\n        if (!systemHotspots[key]) {\n          systemHotspots[key] = {\n            systemName: report.system_name,\n            material: report.material_refined,\n            bodies: [],\n            totalFrequency: 0,\n            activeDays: new Set()\n          }\n        }\n\n        systemHotspots[key].bodies.push({\n          bodyName: report.body_name,\n          frequency: report.mining_frequency,\n          activeDays: report.active_days,\n          firstReport: report.first_report,\n          lastReport: report.last_report\n        })\n\n        systemHotspots[key].totalFrequency += report.mining_frequency\n        systemHotspots[key].activeDays.add(report.active_days)\n      }\n\n      // Convert to array and sort by frequency\n      const hotspots = Object.values(systemHotspots)\n        .map(hotspot => ({\n          ...hotspot,\n          activeDays: Array.from(hotspot.activeDays).reduce((a, b) => a + b, 0)\n        }))\n        .sort((a, b) => b.totalFrequency - a.totalFrequency)\n\n      return hotspots\n    } catch (error) {\n      logger.error('Error generating hotspot analysis:', error)\n      return []\n    }\n  }\n\n  getStatistics () {\n    return {\n      ...this.statistics,\n      queueSize: this.processingQueue.length,\n      isProcessing: this.isProcessing\n    }\n  }\n\n  resetStatistics () {\n    this.statistics = {\n      totalProcessed: 0,\n      miningReports: 0,\n      commodityUpdates: 0,\n      systemUpdates: 0,\n      errors: 0\n    }\n  }\n}\n\nmodule.exports = DataProcessor\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\database.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\edsmApiService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'attempt' is defined but never used. Allowed unused args must match /^_/u.","line":234,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":234,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const axios = require('axios')\nconst logger = require('./logger')\n\n/**\n * Enhanced EDSM API Service\n * Comprehensive integration with Elite Dangerous Star Map API\n * Includes rate limiting, error handling, caching, and retry mechanisms\n */\nclass EDSMApiService {\n  constructor (config = {}) {\n    this.baseURL = config.baseURL || 'https://www.edsm.net/api-v1'\n    this.timeout = config.timeout || 10000\n    this.maxRetries = config.maxRetries || 3\n    this.retryDelay = config.retryDelay || 1000\n    this.rateLimit = config.rateLimit || { maxRequests: 100, windowMs: 60000 }\n\n    // Rate limiting tracking\n    this.requestQueue = []\n    this.requestHistory = []\n\n    // Circuit breaker state\n    this.circuitBreaker = {\n      isOpen: false,\n      failureCount: 0,\n      lastFailureTime: null,\n      threshold: config.circuitBreakerThreshold || 5,\n      timeout: config.circuitBreakerTimeout || 60000\n    }\n\n    // Initialize HTTP client with optimized settings\n    this.client = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        'User-Agent': 'EliteMiningDataServer/2.0',\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      },\n      // Connection pooling\n      maxRedirects: 3,\n      validateStatus: (status) => status < 500 // Don't throw for 4xx errors\n    })\n\n    // Setup request/response interceptors\n    this.setupInterceptors()\n\n    // Start rate limiter cleanup\n    this.startRateLimiterCleanup()\n\n    logger.info('EDSM API Service initialized', {\n      baseURL: this.baseURL,\n      rateLimit: this.rateLimit,\n      timeout: this.timeout\n    })\n  }\n\n  /**\n   * Setup axios interceptors for logging and error handling\n   */\n  setupInterceptors () {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config) => {\n        logger.debug('EDSM API Request', {\n          method: config.method,\n          url: config.url,\n          params: config.params\n        })\n        return config\n      },\n      (error) => {\n        logger.error('EDSM API Request Error', error)\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        logger.debug('EDSM API Response', {\n          status: response.status,\n          url: response.config.url,\n          dataLength: response.data ? Object.keys(response.data).length : 0\n        })\n\n        // Reset circuit breaker on successful response\n        this.resetCircuitBreaker()\n\n        return response\n      },\n      (error) => {\n        logger.error('EDSM API Response Error', {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          url: error.config?.url,\n          message: error.message\n        })\n\n        // Update circuit breaker on error\n        this.recordFailure()\n\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  /**\n   * Rate limiting implementation\n   */\n  async checkRateLimit () {\n    const now = Date.now()\n\n    // Clean old requests from history\n    this.requestHistory = this.requestHistory.filter(\n      timestamp => now - timestamp < this.rateLimit.windowMs\n    )\n\n    // Check if we're within rate limits\n    if (this.requestHistory.length >= this.rateLimit.maxRequests) {\n      const oldestRequest = this.requestHistory[0]\n      const waitTime = this.rateLimit.windowMs - (now - oldestRequest)\n\n      if (waitTime > 0) {\n        logger.warn('EDSM API rate limit reached, waiting', { waitTime })\n        await this.sleep(waitTime)\n      }\n    }\n\n    // Record this request\n    this.requestHistory.push(now)\n  }\n\n  /**\n   * Circuit breaker implementation\n   */\n  checkCircuitBreaker () {\n    if (!this.circuitBreaker.isOpen) {\n      return true\n    }\n\n    const now = Date.now()\n    if (now - this.circuitBreaker.lastFailureTime > this.circuitBreaker.timeout) {\n      logger.info('EDSM API circuit breaker half-open, attempting request')\n      this.circuitBreaker.isOpen = false\n      this.circuitBreaker.failureCount = 0\n      return true\n    }\n\n    throw new Error('EDSM API circuit breaker is open')\n  }\n\n  /**\n   * Record API failure for circuit breaker\n   */\n  recordFailure () {\n    this.circuitBreaker.failureCount++\n    this.circuitBreaker.lastFailureTime = Date.now()\n\n    if (this.circuitBreaker.failureCount >= this.circuitBreaker.threshold) {\n      this.circuitBreaker.isOpen = true\n      logger.warn('EDSM API circuit breaker opened', {\n        failureCount: this.circuitBreaker.failureCount,\n        threshold: this.circuitBreaker.threshold\n      })\n    }\n  }\n\n  /**\n   * Reset circuit breaker on successful request\n   */\n  resetCircuitBreaker () {\n    if (this.circuitBreaker.failureCount > 0) {\n      this.circuitBreaker.failureCount = 0\n      this.circuitBreaker.isOpen = false\n      logger.info('EDSM API circuit breaker reset')\n    }\n  }\n\n  /**\n   * Make HTTP request with retry logic\n   */\n  async makeRequest (endpoint, params = {}, options = {}) {\n    // Check circuit breaker\n    this.checkCircuitBreaker()\n\n    // Apply rate limiting\n    await this.checkRateLimit()\n\n    const maxRetries = options.maxRetries || this.maxRetries\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await this.client.get(endpoint, { params })\n\n        // Validate response\n        if (response.status >= 400) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n        }\n\n        return response.data\n      } catch (error) {\n        const isLastAttempt = attempt === maxRetries\n        const shouldRetry = this.shouldRetry(error, attempt)\n\n        if (!isLastAttempt && shouldRetry) {\n          const delay = this.calculateRetryDelay(attempt)\n          logger.warn('EDSM API request failed, retrying', {\n            endpoint,\n            attempt,\n            maxRetries,\n            delay,\n            error: error.message\n          })\n\n          await this.sleep(delay)\n          continue\n        }\n\n        // Final failure\n        logger.error('EDSM API request failed permanently', {\n          endpoint,\n          attempts: attempt,\n          error: error.message\n        })\n\n        throw new Error(`EDSM API request failed: ${error.message}`)\n      }\n    }\n  }\n\n  /**\n   * Determine if request should be retried\n   */\n  shouldRetry (error, attempt) {\n    // Don't retry on client errors (4xx)\n    if (error.response && error.response.status >= 400 && error.response.status < 500) {\n      return false\n    }\n\n    // Retry on network errors, timeouts, and server errors (5xx)\n    return error.code === 'ECONNRESET' ||\n           error.code === 'ETIMEDOUT' ||\n           error.code === 'ECONNREFUSED' ||\n           (error.response && error.response.status >= 500)\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   */\n  calculateRetryDelay (attempt) {\n    const exponentialDelay = this.retryDelay * Math.pow(2, attempt - 1)\n    const jitter = Math.random() * 1000 // Add jitter to prevent thundering herd\n    return Math.min(exponentialDelay + jitter, 30000) // Cap at 30 seconds\n  }\n\n  /**\n   * Utility sleep function\n   */\n  sleep (ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Start rate limiter cleanup interval\n   */\n  startRateLimiterCleanup () {\n    setInterval(() => {\n      const now = Date.now()\n      this.requestHistory = this.requestHistory.filter(\n        timestamp => now - timestamp < this.rateLimit.windowMs\n      )\n    }, this.rateLimit.windowMs)\n  }\n\n  /**\n   * Get system information by name\n   */\n  async getSystem (systemName, options = {}) {\n    try {\n      const params = {\n        systemName,\n        showCoordinates: options.showCoordinates !== false ? 1 : 0,\n        showInformation: options.showInformation !== false ? 1 : 0,\n        showId: options.showId !== false ? 1 : 0,\n        showPermit: options.showPermit !== false ? 1 : 0,\n        showPrimaryStar: options.showPrimaryStar !== false ? 1 : 0\n      }\n\n      const data = await this.makeRequest('/system', params)\n\n      if (!data || Object.keys(data).length === 0) {\n        throw new Error(`System '${systemName}' not found`)\n      }\n\n      return this.transformSystemData(data)\n    } catch (error) {\n      logger.error('Failed to get system data', { systemName, error: error.message })\n      throw new Error(`Failed to get system data: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get multiple systems within radius\n   */\n  async getSystemsInRadius (referenceSystem, radius, options = {}) {\n    try {\n      const params = {\n        systemName: referenceSystem,\n        radius: Math.min(radius, 100), // EDSM max radius is 100ly\n        showCoordinates: 1,\n        showInformation: options.showInformation ? 1 : 0,\n        showId: options.showId ? 1 : 0\n      }\n\n      const data = await this.makeRequest('/sphere-systems', params)\n\n      if (!Array.isArray(data)) {\n        throw new Error('Invalid response format from EDSM API')\n      }\n\n      return data.map(system => this.transformSystemData(system))\n    } catch (error) {\n      logger.error('Failed to get systems in radius', {\n        referenceSystem,\n        radius,\n        error: error.message\n      })\n      throw new Error(`Failed to get systems in radius: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get system bodies (planets, stars, etc.)\n   */\n  async getSystemBodies (systemName) {\n    try {\n      const params = {\n        systemName\n      }\n\n      const data = await this.makeRequest('/system/bodies', params)\n\n      if (!data || !data.bodies) {\n        throw new Error(`No bodies found for system '${systemName}'`)\n      }\n\n      return {\n        system: data.name,\n        bodyCount: data.bodyCount || 0,\n        bodies: data.bodies.map(body => this.transformBodyData(body))\n      }\n    } catch (error) {\n      logger.error('Failed to get system bodies', { systemName, error: error.message })\n      throw new Error(`Failed to get system bodies: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get system stations\n   */\n  async getSystemStations (systemName) {\n    try {\n      const params = {\n        systemName\n      }\n\n      const data = await this.makeRequest('/system/stations', params)\n\n      if (!data || !data.stations) {\n        return {\n          system: systemName,\n          stationCount: 0,\n          stations: []\n        }\n      }\n\n      return {\n        system: data.name,\n        stationCount: data.stations.length,\n        stations: data.stations.map(station => this.transformStationData(station))\n      }\n    } catch (error) {\n      logger.error('Failed to get system stations', { systemName, error: error.message })\n      throw new Error(`Failed to get system stations: ${error.message}`)\n    }\n  }\n\n  /**\n   * Search systems by name\n   */\n  async searchSystems (query, options = {}) {\n    try {\n      const params = {\n        systemName: query,\n        showCoordinates: 1,\n        showInformation: options.showInformation ? 1 : 0\n      }\n\n      const data = await this.makeRequest('/systems', params)\n\n      if (!Array.isArray(data)) {\n        return []\n      }\n\n      return data.map(system => this.transformSystemData(system))\n    } catch (error) {\n      logger.error('Failed to search systems', { query, error: error.message })\n      throw new Error(`Failed to search systems: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get traffic report for system\n   */\n  async getSystemTraffic (systemName) {\n    try {\n      const params = {\n        systemName\n      }\n\n      const data = await this.makeRequest('/system/traffic', params)\n\n      return {\n        system: systemName,\n        traffic: data || {},\n        breakdown: data.breakdown || {},\n        total: data.total || 0\n      }\n    } catch (error) {\n      logger.error('Failed to get system traffic', { systemName, error: error.message })\n      throw new Error(`Failed to get system traffic: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get system deaths (dangerous systems)\n   */\n  async getSystemDeaths (systemName) {\n    try {\n      const params = {\n        systemName\n      }\n\n      const data = await this.makeRequest('/system/deaths', params)\n\n      return {\n        system: systemName,\n        deaths: data.deaths || 0,\n        breakdown: data.breakdown || {}\n      }\n    } catch (error) {\n      logger.error('Failed to get system deaths', { systemName, error: error.message })\n      throw new Error(`Failed to get system deaths: ${error.message}`)\n    }\n  }\n\n  /**\n   * Transform raw system data to standardized format\n   */\n  transformSystemData (system) {\n    return {\n      name: system.name,\n      id: system.id || null,\n      id64: system.id64 || null,\n      coords: system.coords\n        ? {\n            x: parseFloat(system.coords.x),\n            y: parseFloat(system.coords.y),\n            z: parseFloat(system.coords.z)\n          }\n        : null,\n      coordsLocked: system.coordsLocked || false,\n      requirePermit: system.requirePermit || false,\n      permitName: system.permitName || null,\n      information: system.information\n        ? {\n            allegiance: system.information.allegiance || null,\n            government: system.information.government || null,\n            faction: system.information.faction || null,\n            factionState: system.information.factionState || null,\n            population: system.information.population || 0,\n            security: system.information.security || null,\n            economy: system.information.economy || null,\n            secondEconomy: system.information.secondEconomy || null,\n            reserve: system.information.reserve || null\n          }\n        : null,\n      primaryStar: system.primaryStar\n        ? {\n            type: system.primaryStar.type,\n            name: system.primaryStar.name,\n            isScoopable: system.primaryStar.isScoopable || false\n          }\n        : null,\n      date: system.date || null,\n      distanceLy: system.distance || null\n    }\n  }\n\n  /**\n   * Transform raw body data to standardized format\n   */\n  transformBodyData (body) {\n    return {\n      id: body.id || null,\n      id64: body.id64 || null,\n      name: body.name,\n      type: body.type || 'Unknown',\n      subType: body.subType || null,\n      distanceToArrival: body.distanceToArrival || 0,\n      isMainStar: body.isMainStar || false,\n      isScoopable: body.isScoopable || false,\n      age: body.age || null,\n      spectralClass: body.spectralClass || null,\n      luminosity: body.luminosity || null,\n      absoluteMagnitude: body.absoluteMagnitude || null,\n      solarMasses: body.solarMasses || null,\n      solarRadius: body.solarRadius || null,\n      surfaceTemperature: body.surfaceTemperature || null,\n      orbitalPeriod: body.orbitalPeriod || null,\n      semiMajorAxis: body.semiMajorAxis || null,\n      orbitalEccentricity: body.orbitalEccentricity || null,\n      orbitalInclination: body.orbitalInclination || null,\n      argOfPeriapsis: body.argOfPeriapsis || null,\n      rotationalPeriod: body.rotationalPeriod || null,\n      rotationalPeriodTidallyLocked: body.rotationalPeriodTidallyLocked || false,\n      axialTilt: body.axialTilt || null,\n      rings: body.rings || [],\n      belts: body.belts || [],\n      materials: body.materials || {},\n      terraformingState: body.terraformingState || null,\n      planetClass: body.planetClass || null,\n      atmosphere: body.atmosphere || null,\n      atmosphereType: body.atmosphereType || null,\n      volcanism: body.volcanism || null,\n      massEM: body.massEM || null,\n      radius: body.radius || null,\n      surfaceGravity: body.surfaceGravity || null,\n      surfacePressure: body.surfacePressure || null,\n      landable: body.isLandable || false,\n      bodyId: body.bodyId || null,\n      parents: body.parents || [],\n      updateTime: body.updateTime || null\n    }\n  }\n\n  /**\n   * Transform raw station data to standardized format\n   */\n  transformStationData (station) {\n    return {\n      id: station.id || null,\n      name: station.name,\n      type: station.type || 'Unknown',\n      distanceToArrival: station.distanceToArrival || 0,\n      allegiance: station.allegiance || null,\n      government: station.government || null,\n      economy: station.economy || null,\n      secondEconomy: station.secondEconomy || null,\n      haveMarket: station.haveMarket || false,\n      haveShipyard: station.haveShipyard || false,\n      haveOutfitting: station.haveOutfitting || false,\n      otherServices: station.otherServices || [],\n      controllingFaction: station.controllingFaction\n        ? {\n            id: station.controllingFaction.id,\n            name: station.controllingFaction.name\n          }\n        : null,\n      updateTime: station.updateTime || null,\n      body: station.body\n        ? {\n            id: station.body.id,\n            name: station.body.name\n          }\n        : null\n    }\n  }\n\n  /**\n   * Get service health status\n   */\n  getHealthStatus () {\n    return {\n      service: 'EDSM API',\n      status: this.circuitBreaker.isOpen ? 'degraded' : 'healthy',\n      circuitBreaker: {\n        isOpen: this.circuitBreaker.isOpen,\n        failureCount: this.circuitBreaker.failureCount,\n        lastFailureTime: this.circuitBreaker.lastFailureTime\n      },\n      rateLimit: {\n        requestsInWindow: this.requestHistory.length,\n        maxRequests: this.rateLimit.maxRequests,\n        windowMs: this.rateLimit.windowMs\n      },\n      lastRequest: this.requestHistory[this.requestHistory.length - 1] || null\n    }\n  }\n\n  /**\n   * Get service statistics\n   */\n  getStatistics () {\n    const now = Date.now()\n    const recentRequests = this.requestHistory.filter(\n      timestamp => now - timestamp < 300000 // Last 5 minutes\n    )\n\n    return {\n      totalRequestsTracked: this.requestHistory.length,\n      recentRequests: recentRequests.length,\n      circuitBreakerStatus: this.circuitBreaker.isOpen ? 'open' : 'closed',\n      failureCount: this.circuitBreaker.failureCount,\n      averageRequestsPerMinute: this.requestHistory.length > 0\n        ? (this.requestHistory.length / ((now - this.requestHistory[0]) / 60000))\n        : 0\n    }\n  }\n}\n\nmodule.exports = EDSMApiService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\errorHandlingService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'responseTime' is assigned a value but never used.","line":299,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":299,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const logger = require('./logger')\n\n/**\n * Enhanced Error Handling Service\n * Provides comprehensive error handling with circuit breaker pattern,\n * exponential backoff, retry mechanisms, and failure analytics\n */\nclass ErrorHandlingService {\n  constructor (config = {}) {\n    this.globalConfig = {\n      defaultMaxRetries: config.defaultMaxRetries || 3,\n      defaultRetryDelay: config.defaultRetryDelay || 1000,\n      defaultCircuitBreakerThreshold: config.defaultCircuitBreakerThreshold || 5,\n      defaultCircuitBreakerTimeout: config.defaultCircuitBreakerTimeout || 60000,\n      exponentialBackoffMultiplier: config.exponentialBackoffMultiplier || 2,\n      maxBackoffDelay: config.maxBackoffDelay || 60000,\n      jitterEnabled: config.jitterEnabled !== false,\n      healthCheckInterval: config.healthCheckInterval || 30000\n    }\n\n    // Service-specific configurations\n    this.services = new Map()\n\n    // Global error analytics\n    this.analytics = {\n      totalErrors: 0,\n      errorsByType: new Map(),\n      errorsByService: new Map(),\n      circuitBreakerTrips: 0,\n      successfulRetries: 0,\n      failedRetries: 0,\n      averageRecoveryTime: 0\n    }\n\n    // Error classification patterns\n    this.errorPatterns = {\n      network: [\n        'ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'ENOTFOUND',\n        'EHOSTUNREACH', 'ENETUNREACH', 'EPIPE'\n      ],\n      rateLimit: [\n        'rate limit', 'too many requests', '429'\n      ],\n      authentication: [\n        'unauthorized', 'forbidden', '401', '403', 'invalid api key'\n      ],\n      serverError: [\n        '500', '502', '503', '504', 'internal server error',\n        'bad gateway', 'service unavailable', 'gateway timeout'\n      ],\n      clientError: [\n        '400', '404', '409', '422', 'bad request', 'not found',\n        'conflict', 'unprocessable entity'\n      ]\n    }\n\n    // Start health monitoring\n    this.startHealthMonitoring()\n\n    logger.info('Error Handling Service initialized', {\n      defaultMaxRetries: this.globalConfig.defaultMaxRetries,\n      circuitBreakerEnabled: true,\n      exponentialBackoff: true\n    })\n  }\n\n  /**\n   * Register a service with specific error handling configuration\n   */\n  registerService (serviceName, config = {}) {\n    const serviceConfig = {\n      maxRetries: config.maxRetries || this.globalConfig.defaultMaxRetries,\n      retryDelay: config.retryDelay || this.globalConfig.defaultRetryDelay,\n      circuitBreaker: {\n        threshold: config.circuitBreakerThreshold || this.globalConfig.defaultCircuitBreakerThreshold,\n        timeout: config.circuitBreakerTimeout || this.globalConfig.defaultCircuitBreakerTimeout,\n        isOpen: false,\n        failureCount: 0,\n        lastFailureTime: null,\n        halfOpenRetryCount: 0,\n        maxHalfOpenRetries: config.maxHalfOpenRetries || 3\n      },\n      retryableErrors: config.retryableErrors || ['network', 'rateLimit', 'serverError'],\n      nonRetryableErrors: config.nonRetryableErrors || ['authentication', 'clientError'],\n      customErrorHandler: config.customErrorHandler || null,\n      healthCheck: config.healthCheck || null\n    }\n\n    this.services.set(serviceName, {\n      config: serviceConfig,\n      stats: {\n        totalRequests: 0,\n        totalErrors: 0,\n        retriedRequests: 0,\n        circuitBreakerTrips: 0,\n        lastError: null,\n        lastSuccessTime: Date.now(),\n        averageErrorRate: 0,\n        averageRecoveryTime: 0\n      }\n    })\n\n    // Initialize analytics for this service\n    this.analytics.errorsByService.set(serviceName, {\n      total: 0,\n      byType: new Map(),\n      circuitBreakerTrips: 0,\n      successfulRetries: 0,\n      failedRetries: 0\n    })\n\n    logger.info('Registered error handling service', { serviceName, config: serviceConfig })\n  }\n\n  /**\n   * Execute a function with comprehensive error handling\n   */\n  async executeWithErrorHandling (serviceName, fn, options = {}) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      throw new Error(`Service '${serviceName}' not registered with error handler`)\n    }\n\n    const startTime = Date.now()\n    service.stats.totalRequests++\n\n    // Check circuit breaker\n    if (service.config.circuitBreaker.isOpen) {\n      const canRetry = this.checkCircuitBreakerTimeout(service)\n      if (!canRetry) {\n        const error = new Error(`Circuit breaker is open for service '${serviceName}'`)\n        error.type = 'CIRCUIT_BREAKER_OPEN'\n        throw error\n      }\n    }\n\n    const maxRetries = options.maxRetries || service.config.maxRetries\n    let lastError = null\n\n    for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n      try {\n        const result = await fn()\n\n        // Success - update circuit breaker and stats\n        this.recordSuccess(service, serviceName, startTime)\n\n        if (attempt > 1) {\n          // This was a successful retry\n          this.analytics.successfulRetries++\n          this.analytics.errorsByService.get(serviceName).successfulRetries++\n\n          logger.info('Request succeeded after retry', {\n            serviceName,\n            attempt,\n            totalTime: Date.now() - startTime\n          })\n        }\n\n        return result\n      } catch (error) {\n        lastError = error\n        const isLastAttempt = attempt === maxRetries + 1\n\n        // Classify and analyze error\n        const errorType = this.classifyError(error)\n        this.recordError(service, serviceName, error, errorType)\n\n        // Check if error should be retried\n        const shouldRetry = !isLastAttempt && this.shouldRetryError(service, error, errorType, attempt)\n\n        if (!shouldRetry) {\n          // Final failure\n          if (attempt > 1) {\n            this.analytics.failedRetries++\n            this.analytics.errorsByService.get(serviceName).failedRetries++\n          }\n\n          logger.error('Request failed permanently', {\n            serviceName,\n            attempts: attempt,\n            errorType,\n            error: error.message\n          })\n\n          throw this.enhanceError(error, {\n            serviceName,\n            attempts: attempt,\n            errorType,\n            circuitBreakerOpen: service.config.circuitBreaker.isOpen\n          })\n        }\n\n        // Calculate retry delay\n        const delay = this.calculateRetryDelay(service, attempt, errorType)\n\n        logger.warn('Request failed, retrying', {\n          serviceName,\n          attempt,\n          maxRetries: maxRetries + 1,\n          delay,\n          errorType,\n          error: error.message\n        })\n\n        // Wait before retry\n        await this.sleep(delay)\n      }\n    }\n\n    // This should never be reached, but just in case\n    throw lastError\n  }\n\n  /**\n   * Classify error type based on patterns\n   */\n  classifyError (error) {\n    const errorMessage = error.message.toLowerCase()\n    const errorCode = error.code?.toUpperCase()\n    const statusCode = error.response?.status?.toString()\n\n    for (const [type, patterns] of Object.entries(this.errorPatterns)) {\n      for (const pattern of patterns) {\n        if (errorMessage.includes(pattern.toLowerCase()) ||\n            errorCode === pattern ||\n            statusCode === pattern) {\n          return type\n        }\n      }\n    }\n\n    return 'unknown'\n  }\n\n  /**\n   * Determine if error should be retried\n   */\n  shouldRetryError (service, error, errorType, attempt) {\n    // Check if error type is retryable\n    if (service.config.nonRetryableErrors.includes(errorType)) {\n      return false\n    }\n\n    if (!service.config.retryableErrors.includes(errorType) && errorType !== 'unknown') {\n      return false\n    }\n\n    // Use custom error handler if provided\n    if (service.config.customErrorHandler) {\n      return service.config.customErrorHandler(error, errorType, attempt)\n    }\n\n    // Default retry logic for unknown errors - be conservative\n    if (errorType === 'unknown') {\n      return attempt <= 2 // Only retry unknown errors once\n    }\n\n    return true\n  }\n\n  /**\n   * Calculate retry delay with exponential backoff and jitter\n   */\n  calculateRetryDelay (service, attempt, errorType) {\n    let baseDelay = service.config.retryDelay\n\n    // Adjust base delay based on error type\n    switch (errorType) {\n      case 'rateLimit':\n        baseDelay *= 3 // Longer delay for rate limits\n        break\n      case 'serverError':\n        baseDelay *= 2 // Medium delay for server errors\n        break\n      case 'network':\n        baseDelay *= 1.5 // Shorter delay for network errors\n        break\n    }\n\n    // Apply exponential backoff\n    const exponentialDelay = baseDelay * Math.pow(this.globalConfig.exponentialBackoffMultiplier, attempt - 1)\n\n    // Add jitter to prevent thundering herd\n    let jitter = 0\n    if (this.globalConfig.jitterEnabled) {\n      jitter = Math.random() * 1000\n    }\n\n    // Cap at maximum delay\n    const finalDelay = Math.min(exponentialDelay + jitter, this.globalConfig.maxBackoffDelay)\n\n    return Math.floor(finalDelay)\n  }\n\n  /**\n   * Record successful request\n   */\n  recordSuccess (service, serviceName, startTime) {\n    const responseTime = Date.now() - startTime\n\n    // Reset circuit breaker on success\n    if (service.config.circuitBreaker.isOpen) {\n      service.config.circuitBreaker.isOpen = false\n      service.config.circuitBreaker.failureCount = 0\n      service.config.circuitBreaker.halfOpenRetryCount = 0\n\n      // Calculate recovery time\n      const recoveryTime = Date.now() - service.config.circuitBreaker.lastFailureTime\n      this.updateAverageRecoveryTime(service, recoveryTime)\n\n      logger.info('Circuit breaker closed after success', {\n        serviceName,\n        recoveryTime\n      })\n    }\n\n    service.stats.lastSuccessTime = Date.now()\n\n    // Update error rate (moving average)\n    const totalRequests = service.stats.totalRequests\n    const totalErrors = service.stats.totalErrors\n    service.stats.averageErrorRate = totalErrors / totalRequests\n  }\n\n  /**\n   * Record error and update circuit breaker\n   */\n  recordError (service, serviceName, error, errorType) {\n    service.stats.totalErrors++\n    service.stats.lastError = {\n      message: error.message,\n      type: errorType,\n      timestamp: new Date().toISOString()\n    }\n\n    // Update global analytics\n    this.analytics.totalErrors++\n    this.analytics.errorsByType.set(errorType, (this.analytics.errorsByType.get(errorType) || 0) + 1)\n\n    const serviceAnalytics = this.analytics.errorsByService.get(serviceName)\n    serviceAnalytics.total++\n    serviceAnalytics.byType.set(errorType, (serviceAnalytics.byType.get(errorType) || 0) + 1)\n\n    // Update circuit breaker\n    this.updateCircuitBreaker(service, serviceName, errorType)\n\n    // Update error rate\n    const totalRequests = service.stats.totalRequests\n    const totalErrors = service.stats.totalErrors\n    service.stats.averageErrorRate = totalErrors / totalRequests\n  }\n\n  /**\n   * Update circuit breaker state\n   */\n  updateCircuitBreaker (service, serviceName, errorType) {\n    const circuitBreaker = service.config.circuitBreaker\n\n    // Don't trip circuit breaker for client errors\n    if (errorType === 'clientError' || errorType === 'authentication') {\n      return\n    }\n\n    circuitBreaker.failureCount++\n    circuitBreaker.lastFailureTime = Date.now()\n\n    // Check if we should open the circuit breaker\n    if (!circuitBreaker.isOpen && circuitBreaker.failureCount >= circuitBreaker.threshold) {\n      circuitBreaker.isOpen = true\n      service.stats.circuitBreakerTrips++\n      this.analytics.circuitBreakerTrips++\n      this.analytics.errorsByService.get(serviceName).circuitBreakerTrips++\n\n      logger.warn('Circuit breaker opened', {\n        serviceName,\n        failureCount: circuitBreaker.failureCount,\n        threshold: circuitBreaker.threshold\n      })\n    }\n  }\n\n  /**\n   * Check if circuit breaker timeout has expired\n   */\n  checkCircuitBreakerTimeout (service) {\n    const circuitBreaker = service.config.circuitBreaker\n    const now = Date.now()\n\n    if (now - circuitBreaker.lastFailureTime > circuitBreaker.timeout) {\n      // Half-open state - allow limited retries\n      if (circuitBreaker.halfOpenRetryCount < circuitBreaker.maxHalfOpenRetries) {\n        circuitBreaker.halfOpenRetryCount++\n        logger.info('Circuit breaker half-open, allowing retry', {\n          retryCount: circuitBreaker.halfOpenRetryCount,\n          maxRetries: circuitBreaker.maxHalfOpenRetries\n        })\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Update average recovery time\n   */\n  updateAverageRecoveryTime (service, recoveryTime) {\n    const currentAvg = service.stats.averageRecoveryTime\n    const trips = service.stats.circuitBreakerTrips\n\n    if (trips === 1) {\n      service.stats.averageRecoveryTime = recoveryTime\n    } else {\n      service.stats.averageRecoveryTime = (currentAvg * (trips - 1) + recoveryTime) / trips\n    }\n\n    // Update global average\n    const globalAvg = this.analytics.averageRecoveryTime\n    const globalTrips = this.analytics.circuitBreakerTrips\n\n    if (globalTrips === 1) {\n      this.analytics.averageRecoveryTime = recoveryTime\n    } else {\n      this.analytics.averageRecoveryTime = (globalAvg * (globalTrips - 1) + recoveryTime) / globalTrips\n    }\n  }\n\n  /**\n   * Enhance error with additional context\n   */\n  enhanceError (originalError, context) {\n    const enhancedError = new Error(originalError.message)\n    enhancedError.name = originalError.name\n    enhancedError.originalError = originalError\n    enhancedError.context = context\n    enhancedError.timestamp = new Date().toISOString()\n    enhancedError.stack = originalError.stack\n\n    // Add service-specific error properties\n    enhancedError.serviceName = context.serviceName\n    enhancedError.errorType = context.errorType\n    enhancedError.retryAttempts = context.attempts - 1\n    enhancedError.circuitBreakerOpen = context.circuitBreakerOpen\n\n    return enhancedError\n  }\n\n  /**\n   * Start health monitoring for all services\n   */\n  startHealthMonitoring () {\n    setInterval(async () => {\n      for (const [serviceName, service] of this.services) {\n        if (service.config.healthCheck) {\n          try {\n            await service.config.healthCheck()\n            logger.debug('Health check passed', { serviceName })\n          } catch (error) {\n            logger.warn('Health check failed', {\n              serviceName,\n              error: error.message\n            })\n\n            // Record health check failure\n            this.recordError(service, serviceName, error, 'healthCheck')\n          }\n        }\n      }\n    }, this.globalConfig.healthCheckInterval)\n  }\n\n  /**\n   * Utility sleep function\n   */\n  sleep (ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Get service statistics\n   */\n  getServiceStats (serviceName) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      return null\n    }\n\n    return {\n      serviceName,\n      config: service.config,\n      stats: service.stats,\n      circuitBreaker: {\n        isOpen: service.config.circuitBreaker.isOpen,\n        failureCount: service.config.circuitBreaker.failureCount,\n        lastFailureTime: service.config.circuitBreaker.lastFailureTime,\n        halfOpenRetryCount: service.config.circuitBreaker.halfOpenRetryCount\n      },\n      analytics: this.analytics.errorsByService.get(serviceName)\n    }\n  }\n\n  /**\n   * Get global analytics\n   */\n  getGlobalAnalytics () {\n    return {\n      ...this.analytics,\n      errorsByType: Object.fromEntries(this.analytics.errorsByType),\n      errorsByService: Object.fromEntries(\n        Array.from(this.analytics.errorsByService.entries()).map(([service, data]) => [\n          service,\n          {\n            ...data,\n            byType: Object.fromEntries(data.byType)\n          }\n        ])\n      ),\n      totalServices: this.services.size,\n      servicesWithOpenCircuitBreakers: Array.from(this.services.entries())\n        .filter(([, service]) => service.config.circuitBreaker.isOpen)\n        .map(([name]) => name)\n    }\n  }\n\n  /**\n   * Get health status\n   */\n  getHealthStatus () {\n    const openCircuitBreakers = Array.from(this.services.entries())\n      .filter(([, service]) => service.config.circuitBreaker.isOpen)\n\n    const totalRequests = Array.from(this.services.values())\n      .reduce((sum, service) => sum + service.stats.totalRequests, 0)\n\n    const globalErrorRate = totalRequests > 0 ? this.analytics.totalErrors / totalRequests : 0\n\n    let status = 'healthy'\n    if (openCircuitBreakers.length > 0 || globalErrorRate > 0.1) {\n      status = 'degraded'\n    }\n    if (openCircuitBreakers.length > this.services.size / 2 || globalErrorRate > 0.3) {\n      status = 'unhealthy'\n    }\n\n    return {\n      service: 'Error Handling Service',\n      status,\n      totalServices: this.services.size,\n      openCircuitBreakers: openCircuitBreakers.length,\n      globalErrorRate,\n      totalErrors: this.analytics.totalErrors,\n      circuitBreakerTrips: this.analytics.circuitBreakerTrips,\n      averageRecoveryTime: this.analytics.averageRecoveryTime\n    }\n  }\n\n  /**\n   * Reset circuit breaker for a service (manual intervention)\n   */\n  resetCircuitBreaker (serviceName) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      throw new Error(`Service '${serviceName}' not found`)\n    }\n\n    service.config.circuitBreaker.isOpen = false\n    service.config.circuitBreaker.failureCount = 0\n    service.config.circuitBreaker.halfOpenRetryCount = 0\n\n    logger.info('Circuit breaker manually reset', { serviceName })\n  }\n\n  /**\n   * Cleanup and shutdown\n   */\n  shutdown () {\n    logger.info('Error Handling Service shut down')\n  }\n}\n\nmodule.exports = ErrorHandlingService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\healthCheckService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'path' is assigned a value but never used.","line":10,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":11},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[888,953],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[1001,1069],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'stats' is assigned a value but never used.","line":227,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":227,"endColumn":18},{"ruleId":"promise/param-names","severity":2,"message":"Promise constructor parameters must be named to match \"^_?resolve$\"","line":574,"column":25,"nodeType":"Identifier","messageId":"resolveParamNames","endLine":574,"endColumn":26}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Health Check Service\n * Provides comprehensive health monitoring for all system components\n */\n\nconst mongoose = require('mongoose')\nconst Redis = require('redis')\nconst os = require('os')\nconst fs = require('fs').promises\nconst path = require('path')\n\nclass HealthCheckService {\n  constructor () {\n    this.startTime = Date.now()\n    this.checks = new Map()\n    this.healthHistory = []\n    this.maxHistoryEntries = 100\n    this.redisClient = null\n    this.setupRedisConnection()\n  }\n\n  /**\n     * Setup Redis connection for health checks\n     */\n  async setupRedisConnection () {\n    try {\n      if (process.env.REDIS_URL) {\n        this.redisClient = Redis.createClient({\n          url: process.env.REDIS_URL,\n          socket: {\n            connectTimeout: 5000,\n            commandTimeout: 5000\n          }\n        })\n\n        this.redisClient.on('error', (err) => {\n          console.warn('Redis health check connection error:', err.message)\n        })\n      }\n    } catch (error) {\n      console.warn('Redis setup for health checks failed:', error.message)\n    }\n  }\n\n  /**\n     * Perform comprehensive health check\n     */\n  async performHealthCheck () {\n    const healthStatus = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: this.getUptime(),\n      version: process.env.npm_package_version || 'unknown',\n      environment: process.env.NODE_ENV || 'development',\n      checks: {},\n      system: await this.getSystemMetrics(),\n      summary: {\n        total: 0,\n        healthy: 0,\n        unhealthy: 0,\n        degraded: 0\n      }\n    }\n\n    // Core system checks\n    const checks = [\n      { name: 'database', check: this.checkDatabase },\n      { name: 'redis', check: this.checkRedis },\n      { name: 'filesystem', check: this.checkFilesystem },\n      { name: 'memory', check: this.checkMemory },\n      { name: 'cpu', check: this.checkCPU },\n      { name: 'externalApis', check: this.checkExternalAPIs },\n      { name: 'eddn', check: this.checkEDDN },\n      { name: 'websocket', check: this.checkWebSocket }\n    ]\n\n    // Execute all checks in parallel\n    const checkPromises = checks.map(async ({ name, check }) => {\n      try {\n        const result = await Promise.race([\n          check.call(this),\n          this.timeoutPromise(10000, `${name} check timeout`)\n        ])\n\n        healthStatus.checks[name] = {\n          status: result.status,\n          message: result.message,\n          responseTime: result.responseTime || 0,\n          details: result.details || {},\n          lastChecked: new Date().toISOString()\n        }\n\n        healthStatus.summary.total++\n        healthStatus.summary[result.status]++\n      } catch (error) {\n        healthStatus.checks[name] = {\n          status: 'unhealthy',\n          message: error.message,\n          responseTime: 0,\n          details: { error: error.stack },\n          lastChecked: new Date().toISOString()\n        }\n\n        healthStatus.summary.total++\n        healthStatus.summary.unhealthy++\n      }\n    })\n\n    await Promise.all(checkPromises)\n\n    // Determine overall health status\n    if (healthStatus.summary.unhealthy > 0) {\n      healthStatus.status = 'unhealthy'\n    } else if (healthStatus.summary.degraded > 0) {\n      healthStatus.status = 'degraded'\n    }\n\n    // Store health history\n    this.healthHistory.push({\n      timestamp: healthStatus.timestamp,\n      status: healthStatus.status,\n      summary: healthStatus.summary\n    })\n\n    // Limit history size\n    if (this.healthHistory.length > this.maxHistoryEntries) {\n      this.healthHistory = this.healthHistory.slice(-this.maxHistoryEntries)\n    }\n\n    return healthStatus\n  }\n\n  /**\n     * Check MongoDB database connection and performance\n     */\n  async checkDatabase () {\n    const startTime = Date.now()\n\n    try {\n      if (mongoose.connection.readyState !== 1) {\n        return {\n          status: 'unhealthy',\n          message: 'MongoDB not connected',\n          responseTime: Date.now() - startTime\n        }\n      }\n\n      // Test database query performance\n      const db = mongoose.connection.db\n      await db.admin().ping()\n\n      const stats = await db.stats()\n      const responseTime = Date.now() - startTime\n\n      return {\n        status: responseTime < 1000 ? 'healthy' : 'degraded',\n        message: `MongoDB connected (${responseTime}ms)`,\n        responseTime,\n        details: {\n          collections: stats.collections,\n          dataSize: this.formatBytes(stats.dataSize),\n          indexSize: this.formatBytes(stats.indexSize),\n          avgObjSize: Math.round(stats.avgObjSize)\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `Database error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check Redis connection and performance\n     */\n  async checkRedis () {\n    const startTime = Date.now()\n\n    try {\n      if (!this.redisClient) {\n        return {\n          status: 'degraded',\n          message: 'Redis not configured',\n          responseTime: 0,\n          details: { configured: false }\n        }\n      }\n\n      if (!this.redisClient.isOpen) {\n        await this.redisClient.connect()\n      }\n\n      await this.redisClient.ping()\n      const info = await this.redisClient.info('memory')\n      const responseTime = Date.now() - startTime\n\n      const memoryMatch = info.match(/used_memory_human:(.+)/)\n      const memoryUsed = memoryMatch ? memoryMatch[1].trim() : 'unknown'\n\n      return {\n        status: responseTime < 500 ? 'healthy' : 'degraded',\n        message: `Redis connected (${responseTime}ms)`,\n        responseTime,\n        details: {\n          memoryUsed,\n          connected: true\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `Redis error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check filesystem health and disk space\n     */\n  async checkFilesystem () {\n    const startTime = Date.now()\n\n    try {\n      const stats = await fs.stat(process.cwd())\n      const { size: totalSpace, free: freeSpace } = await this.getDiskSpace()\n\n      const usedSpace = totalSpace - freeSpace\n      const usagePercent = (usedSpace / totalSpace) * 100\n\n      let status = 'healthy'\n      let message = `Filesystem accessible (${usagePercent.toFixed(1)}% used)`\n\n      if (usagePercent > 90) {\n        status = 'unhealthy'\n        message = `Disk space critical (${usagePercent.toFixed(1)}% used)`\n      } else if (usagePercent > 80) {\n        status = 'degraded'\n        message = `Disk space warning (${usagePercent.toFixed(1)}% used)`\n      }\n\n      return {\n        status,\n        message,\n        responseTime: Date.now() - startTime,\n        details: {\n          totalSpace: this.formatBytes(totalSpace),\n          freeSpace: this.formatBytes(freeSpace),\n          usedSpace: this.formatBytes(usedSpace),\n          usagePercent: Math.round(usagePercent * 10) / 10\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `Filesystem error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check memory usage\n     */\n  async checkMemory () {\n    const startTime = Date.now()\n\n    try {\n      const memUsage = process.memoryUsage()\n      const systemMem = {\n        total: os.totalmem(),\n        free: os.freemem()\n      }\n\n      const heapUsagePercent = (memUsage.heapUsed / memUsage.heapTotal) * 100\n      const systemUsagePercent = ((systemMem.total - systemMem.free) / systemMem.total) * 100\n\n      let status = 'healthy'\n      let message = `Memory usage normal (${heapUsagePercent.toFixed(1)}% heap)`\n\n      if (heapUsagePercent > 90 || systemUsagePercent > 95) {\n        status = 'unhealthy'\n        message = `Memory usage critical (${heapUsagePercent.toFixed(1)}% heap, ${systemUsagePercent.toFixed(1)}% system)`\n      } else if (heapUsagePercent > 80 || systemUsagePercent > 85) {\n        status = 'degraded'\n        message = `Memory usage warning (${heapUsagePercent.toFixed(1)}% heap, ${systemUsagePercent.toFixed(1)}% system)`\n      }\n\n      return {\n        status,\n        message,\n        responseTime: Date.now() - startTime,\n        details: {\n          heap: {\n            used: this.formatBytes(memUsage.heapUsed),\n            total: this.formatBytes(memUsage.heapTotal),\n            usagePercent: Math.round(heapUsagePercent * 10) / 10\n          },\n          system: {\n            used: this.formatBytes(systemMem.total - systemMem.free),\n            total: this.formatBytes(systemMem.total),\n            free: this.formatBytes(systemMem.free),\n            usagePercent: Math.round(systemUsagePercent * 10) / 10\n          },\n          rss: this.formatBytes(memUsage.rss),\n          external: this.formatBytes(memUsage.external)\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `Memory check error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check CPU usage\n     */\n  async checkCPU () {\n    const startTime = Date.now()\n\n    try {\n      const cpus = os.cpus()\n      const loadAvg = os.loadavg()\n      const numCPUs = cpus.length\n\n      // Calculate CPU usage percentage (simplified)\n      const loadPercent = (loadAvg[0] / numCPUs) * 100\n\n      let status = 'healthy'\n      let message = `CPU load normal (${loadPercent.toFixed(1)}%)`\n\n      if (loadPercent > 90) {\n        status = 'unhealthy'\n        message = `CPU load critical (${loadPercent.toFixed(1)}%)`\n      } else if (loadPercent > 70) {\n        status = 'degraded'\n        message = `CPU load warning (${loadPercent.toFixed(1)}%)`\n      }\n\n      return {\n        status,\n        message,\n        responseTime: Date.now() - startTime,\n        details: {\n          cores: numCPUs,\n          model: cpus[0]?.model || 'unknown',\n          speed: cpus[0]?.speed || 0,\n          loadAverage: {\n            '1min': Math.round(loadAvg[0] * 100) / 100,\n            '5min': Math.round(loadAvg[1] * 100) / 100,\n            '15min': Math.round(loadAvg[2] * 100) / 100\n          },\n          loadPercent: Math.round(loadPercent * 10) / 10\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `CPU check error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check external API dependencies\n     */\n  async checkExternalAPIs () {\n    const startTime = Date.now()\n\n    try {\n      const apiChecks = [\n        { name: 'EDSM', url: 'https://www.edsm.net/api-status' },\n        { name: 'Inara', url: 'https://inara.cz/elite/' }\n      ]\n\n      const results = await Promise.allSettled(\n        apiChecks.map(async api => {\n          const response = await fetch(api.url, {\n            method: 'HEAD',\n            timeout: 5000\n          })\n          return {\n            name: api.name,\n            status: response.ok ? 'healthy' : 'unhealthy',\n            statusCode: response.status\n          }\n        })\n      )\n\n      const apiStatus = {}\n      let healthyCount = 0\n\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          apiStatus[apiChecks[index].name] = result.value\n          if (result.value.status === 'healthy') healthyCount++\n        } else {\n          apiStatus[apiChecks[index].name] = {\n            name: apiChecks[index].name,\n            status: 'unhealthy',\n            error: result.reason.message\n          }\n        }\n      })\n\n      const responseTime = Date.now() - startTime\n      const totalAPIs = apiChecks.length\n\n      let status = 'healthy'\n      let message = `All external APIs accessible (${healthyCount}/${totalAPIs})`\n\n      if (healthyCount === 0) {\n        status = 'unhealthy'\n        message = `All external APIs unreachable (0/${totalAPIs})`\n      } else if (healthyCount < totalAPIs) {\n        status = 'degraded'\n        message = `Some external APIs unreachable (${healthyCount}/${totalAPIs})`\n      }\n\n      return {\n        status,\n        message,\n        responseTime,\n        details: apiStatus\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `External API check error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check EDDN connection status\n     */\n  async checkEDDN () {\n    const startTime = Date.now()\n\n    try {\n      // This would check the actual EDDN service status\n      // For now, we'll simulate based on common patterns\n\n      const status = 'healthy' // Would be determined by actual EDDN connection\n      const lastMessageTime = Date.now() - (Math.random() * 30000) // Simulate recent message\n      const messageAge = Date.now() - lastMessageTime\n\n      let healthStatus = 'healthy'\n      let message = `EDDN connected (last message ${Math.round(messageAge / 1000)}s ago)`\n\n      if (messageAge > 300000) { // 5 minutes\n        healthStatus = 'unhealthy'\n        message = `EDDN stale (last message ${Math.round(messageAge / 60000)}m ago)`\n      } else if (messageAge > 120000) { // 2 minutes\n        healthStatus = 'degraded'\n        message = `EDDN slow (last message ${Math.round(messageAge / 1000)}s ago)`\n      }\n\n      return {\n        status: healthStatus,\n        message,\n        responseTime: Date.now() - startTime,\n        details: {\n          connected: status === 'healthy',\n          lastMessageAge: Math.round(messageAge / 1000),\n          messagesPerMinute: Math.round(Math.random() * 100) // Would be actual metric\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `EDDN check error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Check WebSocket server status\n     */\n  async checkWebSocket () {\n    const startTime = Date.now()\n\n    try {\n      // Would check actual WebSocket server status\n      const activeConnections = 0 // Would be from actual WebSocket server\n      const totalConnections = 0 // Would be from actual metrics\n\n      return {\n        status: 'healthy',\n        message: `WebSocket server running (${activeConnections} active connections)`,\n        responseTime: Date.now() - startTime,\n        details: {\n          activeConnections,\n          totalConnections,\n          serverRunning: true\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        message: `WebSocket check error: ${error.message}`,\n        responseTime: Date.now() - startTime\n      }\n    }\n  }\n\n  /**\n     * Get system metrics\n     */\n  async getSystemMetrics () {\n    return {\n      platform: os.platform(),\n      arch: os.arch(),\n      nodeVersion: process.version,\n      hostname: os.hostname(),\n      uptime: os.uptime(),\n      loadAverage: os.loadavg(),\n      cpuCount: os.cpus().length,\n      totalMemory: this.formatBytes(os.totalmem()),\n      freeMemory: this.formatBytes(os.freemem())\n    }\n  }\n\n  /**\n     * Get server uptime\n     */\n  getUptime () {\n    const uptimeMs = Date.now() - this.startTime\n    return {\n      milliseconds: uptimeMs,\n      seconds: Math.floor(uptimeMs / 1000),\n      human: this.formatUptime(uptimeMs)\n    }\n  }\n\n  /**\n     * Get health history\n     */\n  getHealthHistory () {\n    return this.healthHistory\n  }\n\n  /**\n     * Get disk space information\n     */\n  async getDiskSpace () {\n    try {\n      const stats = await fs.statfs(process.cwd())\n      return {\n        size: stats.blocks * stats.blksize,\n        free: stats.bavail * stats.blksize\n      }\n    } catch (error) {\n      // Fallback for systems without statfs\n      return {\n        size: 1000000000000, // 1TB fallback\n        free: 500000000000 // 500GB fallback\n      }\n    }\n  }\n\n  /**\n     * Create timeout promise\n     */\n  timeoutPromise (ms, message) {\n    return new Promise((_, reject) => {\n      setTimeout(() => reject(new Error(message)), ms)\n    })\n  }\n\n  /**\n     * Format bytes to human readable\n     */\n  formatBytes (bytes) {\n    if (bytes === 0) return '0 Bytes'\n    const k = 1024\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n  }\n\n  /**\n     * Format uptime to human readable\n     */\n  formatUptime (ms) {\n    const seconds = Math.floor(ms / 1000)\n    const minutes = Math.floor(seconds / 60)\n    const hours = Math.floor(minutes / 60)\n    const days = Math.floor(hours / 24)\n\n    if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`\n    if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`\n    return `${seconds}s`\n  }\n\n  /**\n     * Cleanup resources\n     */\n  async cleanup () {\n    if (this.redisClient && this.redisClient.isOpen) {\n      await this.redisClient.quit()\n    }\n  }\n}\n\nmodule.exports = HealthCheckService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\inaraApiService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'attempt' is defined but never used. Allowed unused args must match /^_/u.","line":297,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":297,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":410,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":410,"endColumn":45},{"ruleId":"no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":446,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":446,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":575,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":575,"endColumn":45}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const axios = require('axios')\nconst logger = require('./logger')\n\n/**\n * Enhanced Inara API Service\n * Comprehensive integration with Inara Elite Dangerous API\n * Includes authentication, rate limiting, error handling, and retry mechanisms\n */\nclass InaraApiService {\n  constructor (config = {}) {\n    this.baseURL = config.baseURL || 'https://inara.cz/inapi/v1/'\n    this.apiKey = config.apiKey\n    this.appName = config.appName || 'EliteMiningDataServer'\n    this.appVersion = config.appVersion || '2.0'\n    this.isDeveloper = config.isDeveloper || false\n    this.timeout = config.timeout || 15000\n    this.maxRetries = config.maxRetries || 3\n    this.retryDelay = config.retryDelay || 2000\n    this.rateLimit = config.rateLimit || { maxRequests: 30, windowMs: 60000 } // Inara limit: 30/min\n\n    // Request tracking for rate limiting\n    this.requestQueue = []\n    this.requestHistory = []\n\n    // Circuit breaker state\n    this.circuitBreaker = {\n      isOpen: false,\n      failureCount: 0,\n      lastFailureTime: null,\n      threshold: config.circuitBreakerThreshold || 3,\n      timeout: config.circuitBreakerTimeout || 120000 // 2 minutes for Inara\n    }\n\n    // API event types mapping\n    this.eventTypes = {\n      // Commander events\n      GET_COMMANDER_PROFILE: 'getCommanderProfile',\n      GET_COMMANDER_CREDITS: 'getCommanderCredits',\n      GET_COMMANDER_RANKS: 'getCommanderRanks',\n      GET_COMMANDER_REPUTATION: 'getCommanderReputation',\n\n      // Market events\n      GET_COMMODITY_PRICES: 'getCommodityPrices',\n      GET_MARKET_PRICES: 'getMarketPrices',\n\n      // Station events\n      GET_STATIONS: 'getStations',\n      GET_STATION_MARKET: 'getStationMarket',\n\n      // System events\n      GET_SYSTEMS: 'getSystems',\n      GET_SYSTEM_STATIONS: 'getSystemStations',\n\n      // Community events\n      GET_COMMUNITY_GOALS: 'getCommunityGoals',\n      GET_GALNET_ARTICLES: 'getGalnetArticles',\n\n      // Squadron events\n      GET_SQUADRON_INFO: 'getSquadronInfo',\n      GET_SQUADRON_MEMBERS: 'getSquadronMembers'\n    }\n\n    // Initialize HTTP client\n    this.client = axios.create({\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: {\n        'User-Agent': `${this.appName}/${this.appVersion}`,\n        'Content-Type': 'application/json',\n        Accept: 'application/json'\n      }\n    })\n\n    // Setup interceptors\n    this.setupInterceptors()\n\n    // Start rate limiter cleanup\n    this.startRateLimiterCleanup()\n\n    if (!this.apiKey) {\n      logger.warn('Inara API initialized without API key - some features will be limited')\n    } else {\n      logger.info('Inara API Service initialized', {\n        appName: this.appName,\n        appVersion: this.appVersion,\n        rateLimit: this.rateLimit\n      })\n    }\n  }\n\n  /**\n   * Setup axios interceptors\n   */\n  setupInterceptors () {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config) => {\n        logger.debug('Inara API Request', {\n          method: config.method,\n          url: config.url,\n          eventName: config.data?.events?.[0]?.eventName\n        })\n        return config\n      },\n      (error) => {\n        logger.error('Inara API Request Error', error)\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        logger.debug('Inara API Response', {\n          status: response.status,\n          eventCount: response.data?.events?.length || 0\n        })\n\n        this.resetCircuitBreaker()\n        return response\n      },\n      (error) => {\n        logger.error('Inara API Response Error', {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          message: error.message\n        })\n\n        this.recordFailure()\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  /**\n   * Rate limiting implementation\n   */\n  async checkRateLimit () {\n    const now = Date.now()\n\n    // Clean old requests\n    this.requestHistory = this.requestHistory.filter(\n      timestamp => now - timestamp < this.rateLimit.windowMs\n    )\n\n    // Check if we need to wait\n    if (this.requestHistory.length >= this.rateLimit.maxRequests) {\n      const oldestRequest = this.requestHistory[0]\n      const waitTime = this.rateLimit.windowMs - (now - oldestRequest)\n\n      if (waitTime > 0) {\n        logger.warn('Inara API rate limit reached, waiting', { waitTime })\n        await this.sleep(waitTime)\n      }\n    }\n\n    this.requestHistory.push(now)\n  }\n\n  /**\n   * Circuit breaker check\n   */\n  checkCircuitBreaker () {\n    if (!this.circuitBreaker.isOpen) {\n      return true\n    }\n\n    const now = Date.now()\n    if (now - this.circuitBreaker.lastFailureTime > this.circuitBreaker.timeout) {\n      logger.info('Inara API circuit breaker half-open, attempting request')\n      this.circuitBreaker.isOpen = false\n      this.circuitBreaker.failureCount = 0\n      return true\n    }\n\n    throw new Error('Inara API circuit breaker is open')\n  }\n\n  /**\n   * Record API failure\n   */\n  recordFailure () {\n    this.circuitBreaker.failureCount++\n    this.circuitBreaker.lastFailureTime = Date.now()\n\n    if (this.circuitBreaker.failureCount >= this.circuitBreaker.threshold) {\n      this.circuitBreaker.isOpen = true\n      logger.warn('Inara API circuit breaker opened', {\n        failureCount: this.circuitBreaker.failureCount\n      })\n    }\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  resetCircuitBreaker () {\n    if (this.circuitBreaker.failureCount > 0) {\n      this.circuitBreaker.failureCount = 0\n      this.circuitBreaker.isOpen = false\n      logger.info('Inara API circuit breaker reset')\n    }\n  }\n\n  /**\n   * Make API request with retry logic\n   */\n  async makeRequest (events, options = {}) {\n    this.checkCircuitBreaker()\n    await this.checkRateLimit()\n\n    const requestPayload = this.buildRequestPayload(events)\n    const maxRetries = options.maxRetries || this.maxRetries\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await this.client.post('', requestPayload)\n\n        if (response.status !== 200) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n        }\n\n        // Validate Inara API response format\n        if (!response.data || !Array.isArray(response.data.events)) {\n          throw new Error('Invalid response format from Inara API')\n        }\n\n        // Check for API errors in response\n        const hasErrors = response.data.events.some(event =>\n          event.eventStatus !== 200 && event.eventStatus !== 202\n        )\n\n        if (hasErrors) {\n          const errorEvents = response.data.events.filter(event =>\n            event.eventStatus !== 200 && event.eventStatus !== 202\n          )\n          logger.warn('Inara API returned event errors', { errorEvents })\n        }\n\n        return response.data\n      } catch (error) {\n        const isLastAttempt = attempt === maxRetries\n        const shouldRetry = this.shouldRetry(error, attempt)\n\n        if (!isLastAttempt && shouldRetry) {\n          const delay = this.calculateRetryDelay(attempt)\n          logger.warn('Inara API request failed, retrying', {\n            attempt,\n            maxRetries,\n            delay,\n            error: error.message\n          })\n\n          await this.sleep(delay)\n          continue\n        }\n\n        logger.error('Inara API request failed permanently', {\n          attempts: attempt,\n          error: error.message\n        })\n\n        throw new Error(`Inara API request failed: ${error.message}`)\n      }\n    }\n  }\n\n  /**\n   * Build standard Inara API request payload\n   */\n  buildRequestPayload (events) {\n    if (!Array.isArray(events)) {\n      events = [events]\n    }\n\n    return {\n      header: {\n        appName: this.appName,\n        appVersion: this.appVersion,\n        isDeveloper: this.isDeveloper,\n        APIkey: this.apiKey || '',\n        commanderName: '', // Set per request if needed\n        commanderFrontierID: '' // Set per request if needed\n      },\n      events: events.map((event, index) => ({\n        eventName: event.eventName,\n        eventTimestamp: event.eventTimestamp || new Date().toISOString(),\n        eventData: event.eventData || {},\n        eventCustomID: event.eventCustomID || index\n      }))\n    }\n  }\n\n  /**\n   * Determine if request should be retried\n   */\n  shouldRetry (error, attempt) {\n    // Don't retry on authentication errors\n    if (error.response && error.response.status === 401) {\n      return false\n    }\n\n    // Don't retry on client errors (4xx) except 429 (rate limit)\n    if (error.response && error.response.status >= 400 &&\n        error.response.status < 500 && error.response.status !== 429) {\n      return false\n    }\n\n    // Retry on network errors, timeouts, rate limits, and server errors\n    return error.code === 'ECONNRESET' ||\n           error.code === 'ETIMEDOUT' ||\n           error.code === 'ECONNREFUSED' ||\n           (error.response && (error.response.status >= 500 || error.response.status === 429))\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   */\n  calculateRetryDelay (attempt) {\n    const exponentialDelay = this.retryDelay * Math.pow(2, attempt - 1)\n    const jitter = Math.random() * 1000\n    return Math.min(exponentialDelay + jitter, 60000) // Cap at 1 minute\n  }\n\n  /**\n   * Utility sleep function\n   */\n  sleep (ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Start rate limiter cleanup\n   */\n  startRateLimiterCleanup () {\n    setInterval(() => {\n      const now = Date.now()\n      this.requestHistory = this.requestHistory.filter(\n        timestamp => now - timestamp < this.rateLimit.windowMs\n      )\n    }, this.rateLimit.windowMs)\n  }\n\n  /**\n   * Get commodity market prices\n   */\n  async getCommodityPrices (commodityName, options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_COMMODITY_PRICES,\n        eventData: {\n          commodityName,\n          maxDistanceLy: options.maxDistance || 50,\n          maxAge: options.maxAge || 7 // days\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        commodity: commodityName,\n        prices: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get commodity prices', { commodityName, error: error.message })\n      throw new Error(`Failed to get commodity prices: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get station market data\n   */\n  async getStationMarket (stationId, options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_STATION_MARKET,\n        eventData: {\n          stationID: stationId,\n          maxAge: options.maxAge || 7\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        stationId,\n        market: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get station market', { stationId, error: error.message })\n      throw new Error(`Failed to get station market: ${error.message}`)\n    }\n  }\n\n  /**\n   * Search stations\n   */\n  async getStations (searchCriteria, options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_STATIONS,\n        eventData: {\n          stationName: searchCriteria.stationName || '',\n          systemName: searchCriteria.systemName || '',\n          maxDistanceLy: searchCriteria.maxDistance || 50,\n          minLandingPadSize: searchCriteria.minLandingPadSize || 'S',\n          hasMarket: searchCriteria.hasMarket || false,\n          hasShipyard: searchCriteria.hasShipyard || false,\n          hasOutfitting: searchCriteria.hasOutfitting || false\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        searchCriteria,\n        stations: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get stations', { searchCriteria, error: error.message })\n      throw new Error(`Failed to get stations: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get systems\n   */\n  async getSystems (searchCriteria, options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_SYSTEMS,\n        eventData: {\n          systemName: searchCriteria.systemName || '',\n          maxDistanceLy: searchCriteria.maxDistance || 50,\n          refSystemName: searchCriteria.referenceSystem || '',\n          allegiance: searchCriteria.allegiance || '',\n          government: searchCriteria.government || '',\n          economy: searchCriteria.economy || '',\n          security: searchCriteria.security || ''\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        searchCriteria,\n        systems: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get systems', { searchCriteria, error: error.message })\n      throw new Error(`Failed to get systems: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get community goals\n   */\n  async getCommunityGoals (options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_COMMUNITY_GOALS,\n        eventData: {\n          showInactive: options.showInactive || false\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        communityGoals: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get community goals', { error: error.message })\n      throw new Error(`Failed to get community goals: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get GalNet articles\n   */\n  async getGalnetArticles (options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_GALNET_ARTICLES,\n        eventData: {\n          maxAge: options.maxAge || 30, // days\n          articleText: options.includeText || false\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        articles: eventData.eventData || [],\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get GalNet articles', { error: error.message })\n      throw new Error(`Failed to get GalNet articles: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get commander profile (requires authentication)\n   */\n  async getCommanderProfile (commanderName, options = {}) {\n    if (!this.apiKey) {\n      throw new Error('API key required for commander profile access')\n    }\n\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_COMMANDER_PROFILE,\n        eventData: {\n          searchName: commanderName,\n          showPrivateProfile: options.showPrivate || false\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        commander: eventData.eventData || {},\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get commander profile', { commanderName, error: error.message })\n      throw new Error(`Failed to get commander profile: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get squadron information\n   */\n  async getSquadronInfo (squadronId, options = {}) {\n    try {\n      const event = {\n        eventName: this.eventTypes.GET_SQUADRON_INFO,\n        eventData: {\n          squadronID: squadronId\n        }\n      }\n\n      const response = await this.makeRequest(event)\n      const eventData = response.events[0]\n\n      if (eventData.eventStatus !== 200) {\n        throw new Error(`Inara API error: ${eventData.eventStatusText}`)\n      }\n\n      return {\n        squadron: eventData.eventData || {},\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to get squadron info', { squadronId, error: error.message })\n      throw new Error(`Failed to get squadron info: ${error.message}`)\n    }\n  }\n\n  /**\n   * Batch multiple API calls efficiently\n   */\n  async batchRequests (events, options = {}) {\n    try {\n      const batchSize = options.batchSize || 10 // Inara allows up to 25 events per request\n      const results = []\n\n      for (let i = 0; i < events.length; i += batchSize) {\n        const batch = events.slice(i, i + batchSize)\n        const response = await this.makeRequest(batch)\n        results.push(...response.events)\n\n        // Add delay between batches to respect rate limits\n        if (i + batchSize < events.length) {\n          await this.sleep(1000)\n        }\n      }\n\n      return {\n        results,\n        totalEvents: events.length,\n        successful: results.filter(r => r.eventStatus === 200).length,\n        failed: results.filter(r => r.eventStatus !== 200).length\n      }\n    } catch (error) {\n      logger.error('Failed to execute batch requests', { error: error.message })\n      throw new Error(`Failed to execute batch requests: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get service health status\n   */\n  getHealthStatus () {\n    return {\n      service: 'Inara API',\n      status: this.circuitBreaker.isOpen ? 'degraded' : 'healthy',\n      authenticated: !!this.apiKey,\n      circuitBreaker: {\n        isOpen: this.circuitBreaker.isOpen,\n        failureCount: this.circuitBreaker.failureCount,\n        lastFailureTime: this.circuitBreaker.lastFailureTime\n      },\n      rateLimit: {\n        requestsInWindow: this.requestHistory.length,\n        maxRequests: this.rateLimit.maxRequests,\n        windowMs: this.rateLimit.windowMs\n      },\n      lastRequest: this.requestHistory[this.requestHistory.length - 1] || null\n    }\n  }\n\n  /**\n   * Get service statistics\n   */\n  getStatistics () {\n    const now = Date.now()\n    const recentRequests = this.requestHistory.filter(\n      timestamp => now - timestamp < 300000 // Last 5 minutes\n    )\n\n    return {\n      totalRequestsTracked: this.requestHistory.length,\n      recentRequests: recentRequests.length,\n      circuitBreakerStatus: this.circuitBreaker.isOpen ? 'open' : 'closed',\n      failureCount: this.circuitBreaker.failureCount,\n      averageRequestsPerMinute: this.requestHistory.length > 0\n        ? (this.requestHistory.length / ((now - this.requestHistory[0]) / 60000))\n        : 0,\n      authenticated: !!this.apiKey,\n      availableEvents: Object.keys(this.eventTypes).length\n    }\n  }\n}\n\nmodule.exports = InaraApiService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\logger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\marketDataService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'systemName' is defined but never used. Allowed unused args must match /^_/u.","line":316,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":316,"endColumn":52},{"ruleId":"no-unused-vars","severity":2,"message":"'maxJumps' is defined but never used. Allowed unused args must match /^_/u.","line":316,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":316,"endColumn":62},{"ruleId":"no-unused-vars","severity":2,"message":"'systemName' is defined but never used. Allowed unused args must match /^_/u.","line":408,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":408,"endColumn":35},{"ruleId":"no-unused-vars","severity":2,"message":"'stationName' is defined but never used. Allowed unused args must match /^_/u.","line":408,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":408,"endColumn":48}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const logger = require('./logger')\n\n/**\n * Market Data Service\n * Handles all market-related database operations and calculations\n */\nclass MarketDataService {\n  constructor (mongoService, cacheManager = null) {\n    this.mongo = mongoService\n    this.cache = cacheManager\n    this.collections = {\n      marketData: 'market_data',\n      stations: 'stations',\n      systems: 'systems',\n      commodities: 'commodities',\n      prices: 'commodity_prices'\n    }\n  }\n\n  /**\n   * Get commodity market data with filtering and aggregation\n   */\n  async getCommodityData (commodityId, options = {}) {\n    try {\n      const { systemName, stationName, maxAge = 24 } = options\n\n      // Generate cache key\n      const cacheKey = `commodity:${commodityId}:${systemName || 'all'}:${stationName || 'all'}:${maxAge}`\n\n      // Try to get from cache if available\n      if (this.cache) {\n        const cached = await this.cache.get(cacheKey)\n        if (cached) {\n          logger.debug(`Cache hit for commodity data: ${cacheKey}`)\n          return cached\n        }\n      }\n\n      const maxAgeMs = maxAge * 60 * 60 * 1000 // Convert hours to milliseconds\n      const cutoffTime = new Date(Date.now() - maxAgeMs)\n\n      const pipeline = [\n        {\n          $match: {\n            commodityId,\n            timestamp: { $gte: cutoffTime }\n          }\n        }\n      ]\n\n      // Add system filter if provided\n      if (systemName) {\n        pipeline[0].$match.systemName = new RegExp(systemName, 'i')\n      }\n\n      // Add station filter if provided\n      if (stationName) {\n        pipeline[0].$match.stationName = new RegExp(stationName, 'i')\n      }\n\n      // Aggregate price data\n      pipeline.push(\n        {\n          $group: {\n            _id: {\n              systemName: '$systemName',\n              stationName: '$stationName'\n            },\n            avgBuyPrice: { $avg: '$buyPrice' },\n            avgSellPrice: { $avg: '$sellPrice' },\n            maxBuyPrice: { $max: '$buyPrice' },\n            minSellPrice: { $min: '$sellPrice' },\n            supply: { $last: '$supply' },\n            demand: { $last: '$demand' },\n            lastUpdated: { $last: '$timestamp' },\n            dataPoints: { $sum: 1 }\n          }\n        },\n        {\n          $sort: { lastUpdated: -1 }\n        },\n        {\n          $limit: 50 // Limit results for performance\n        }\n      )\n\n      const db = await this.mongo.getDatabase()\n      const results = await db.collection(this.collections.prices)\n        .aggregate(pipeline)\n        .toArray()\n\n      // Calculate overall statistics\n      const stats = this.calculatePriceStatistics(results)\n\n      const result = {\n        commodity: commodityId,\n        filter: { systemName, stationName },\n        statistics: stats,\n        locations: results.map(result => ({\n          system: result._id.systemName,\n          station: result._id.stationName,\n          prices: {\n            buy: Math.round(result.avgBuyPrice || 0),\n            sell: Math.round(result.avgSellPrice || 0),\n            maxBuy: Math.round(result.maxBuyPrice || 0),\n            minSell: Math.round(result.minSellPrice || 0)\n          },\n          supply: result.supply || 0,\n          demand: result.demand || 0,\n          lastUpdated: result.lastUpdated,\n          dataPoints: result.dataPoints,\n          freshness: this.calculateFreshness(result.lastUpdated)\n        })),\n        totalLocations: results.length,\n        maxAge\n      }\n\n      // Cache the result if cache manager is available\n      if (this.cache) {\n        await this.cache.set(cacheKey, result, 300) // Cache for 5 minutes\n        logger.debug(`Cached commodity data: ${cacheKey}`)\n      }\n\n      return result\n    } catch (error) {\n      logger.error('Error fetching commodity data:', error)\n      throw new Error(`Failed to fetch commodity data: ${error.message}`)\n    }\n  }\n\n  /**\n   * Calculate trading routes between systems\n   */\n  async calculateTradingRoutes (startSystem, options = {}) {\n    try {\n      const { maxJumps = 20, cargoCapacity = 100, minProfit = 1000 } = options\n\n      // First, get systems within jump range\n      const nearbySystemsMap = await this.getNearbySystemsWithCoordinates(startSystem, maxJumps)\n      const nearbySystemNames = Array.from(nearbySystemsMap.keys())\n\n      if (nearbySystemNames.length === 0) {\n        return {\n          startSystem,\n          routes: [],\n          message: 'No nearby systems found or start system coordinates unavailable'\n        }\n      }\n\n      // Get market data for all nearby systems\n      const marketData = await this.getMarketDataForSystems(nearbySystemNames)\n\n      // Calculate profitable routes\n      const routes = this.calculateProfitableRoutes(\n        startSystem,\n        marketData,\n        nearbySystemsMap,\n        { cargoCapacity, minProfit }\n      )\n\n      return {\n        startSystem,\n        maxJumps,\n        cargoCapacity,\n        minProfit,\n        systemsAnalyzed: nearbySystemNames.length,\n        routes: routes.slice(0, 10), // Top 10 routes\n        totalRoutes: routes.length\n      }\n    } catch (error) {\n      logger.error('Error calculating trading routes:', error)\n      throw new Error(`Failed to calculate trading routes: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get market trends for commodities\n   */\n  async getMarketTrends (commodityName, timeRange = '7d') {\n    try {\n      const days = this.parseTimeRange(timeRange)\n      const startDate = new Date(Date.now() - (days * 24 * 60 * 60 * 1000))\n\n      const pipeline = [\n        {\n          $match: {\n            commodityId: commodityName ? new RegExp(commodityName, 'i') : { $exists: true },\n            timestamp: { $gte: startDate }\n          }\n        },\n        {\n          $group: {\n            _id: {\n              commodity: '$commodityId',\n              date: {\n                $dateToString: {\n                  format: '%Y-%m-%d',\n                  date: '$timestamp'\n                }\n              }\n            },\n            avgPrice: { $avg: { $avg: ['$buyPrice', '$sellPrice'] } },\n            volume: { $sum: { $add: ['$supply', '$demand'] } },\n            dataPoints: { $sum: 1 }\n          }\n        },\n        {\n          $sort: { '_id.date': 1 }\n        }\n      ]\n\n      const db = await this.mongo.getDatabase()\n      const results = await db.collection(this.collections.prices)\n        .aggregate(pipeline)\n        .toArray()\n\n      // Group by commodity and calculate trends\n      const trendsBycommodity = this.groupTrendsBycommodity(results)\n      const trendsWithAnalysis = this.analyzeTrends(trendsBycommodity)\n\n      return {\n        commodity: commodityName || 'all',\n        timeRange,\n        period: `${days} days`,\n        trends: trendsWithAnalysis,\n        dataPoints: results.length\n      }\n    } catch (error) {\n      logger.error('Error fetching market trends:', error)\n      throw new Error(`Failed to fetch market trends: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get complete station market data\n   */\n  async getStationMarketData (systemName, stationName) {\n    try {\n      const pipeline = [\n        {\n          $match: {\n            systemName: new RegExp(systemName, 'i'),\n            stationName: new RegExp(stationName, 'i'),\n            timestamp: {\n              $gte: new Date(Date.now() - (24 * 60 * 60 * 1000)) // Last 24 hours\n            }\n          }\n        },\n        {\n          $sort: { timestamp: -1 }\n        },\n        {\n          $group: {\n            _id: '$commodityId',\n            buyPrice: { $first: '$buyPrice' },\n            sellPrice: { $first: '$sellPrice' },\n            supply: { $first: '$supply' },\n            demand: { $first: '$demand' },\n            lastUpdated: { $first: '$timestamp' }\n          }\n        },\n        {\n          $sort: { _id: 1 }\n        }\n      ]\n\n      const db = await this.mongo.getDatabase()\n      const commodities = await db.collection(this.collections.prices)\n        .aggregate(pipeline)\n        .toArray()\n\n      // Get station information\n      const stationInfo = await this.getStationInfo(systemName, stationName)\n\n      return {\n        system: systemName,\n        station: stationName,\n        stationInfo,\n        commodities: commodities.map(commodity => ({\n          name: commodity._id,\n          buyPrice: commodity.buyPrice || 0,\n          sellPrice: commodity.sellPrice || 0,\n          supply: commodity.supply || 0,\n          demand: commodity.demand || 0,\n          profit: this.calculateProfit(commodity.buyPrice, commodity.sellPrice),\n          lastUpdated: commodity.lastUpdated,\n          freshness: this.calculateFreshness(commodity.lastUpdated)\n        })),\n        totalCommodities: commodities.length,\n        lastUpdated: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Error fetching station market data:', error)\n      throw new Error(`Failed to fetch station market data: ${error.message}`)\n    }\n  }\n\n  // Helper methods\n\n  calculatePriceStatistics (results) {\n    if (results.length === 0) return null\n\n    const buyPrices = results.map(r => r.avgBuyPrice).filter(p => p > 0)\n    const sellPrices = results.map(r => r.avgSellPrice).filter(p => p > 0)\n\n    return {\n      avgBuyPrice: buyPrices.length > 0 ? Math.round(buyPrices.reduce((a, b) => a + b, 0) / buyPrices.length) : 0,\n      avgSellPrice: sellPrices.length > 0 ? Math.round(sellPrices.reduce((a, b) => a + b, 0) / sellPrices.length) : 0,\n      priceSpread: sellPrices.length > 0 && buyPrices.length > 0\n        ? Math.round(Math.max(...sellPrices) - Math.min(...buyPrices))\n        : 0,\n      locations: results.length\n    }\n  }\n\n  async getNearbySystemsWithCoordinates (systemName, maxJumps) {\n    // This would integrate with EDSM API to get system coordinates\n    // For now, return a mock implementation\n    const systemsMap = new Map()\n    systemsMap.set('Sol', { x: 0, y: 0, z: 0, distance: 0 })\n    systemsMap.set('Alpha Centauri', { x: 3.03, y: -0.01, z: 3.15, distance: 4.3 })\n    return systemsMap\n  }\n\n  async getMarketDataForSystems (systemNames) {\n    const db = await this.mongo.getDatabase()\n    return await db.collection(this.collections.prices)\n      .find({ systemName: { $in: systemNames } })\n      .toArray()\n  }\n\n  calculateProfitableRoutes (startSystem, marketData, systemsMap, options) {\n    // Complex route calculation logic would go here\n    // For now, return a mock profitable route\n    return [{\n      from: { system: startSystem, station: 'Mock Station A' },\n      to: { system: 'Alpha Centauri', station: 'Mock Station B' },\n      commodity: 'Gold',\n      buyPrice: 9000,\n      sellPrice: 12000,\n      profit: 3000,\n      profitPerTon: 3000,\n      totalProfit: 3000 * options.cargoCapacity,\n      distance: 4.3,\n      jumps: 1\n    }]\n  }\n\n  parseTimeRange (timeRange) {\n    const match = timeRange.match(/(\\d+)([dwmy])/)\n    if (!match) return 7 // Default to 7 days\n\n    const [, number, unit] = match\n    const multipliers = { d: 1, w: 7, m: 30, y: 365 }\n    return parseInt(number) * (multipliers[unit] || 1)\n  }\n\n  groupTrendsBycommodity (results) {\n    const grouped = {}\n    results.forEach(result => {\n      const commodity = result._id.commodity\n      if (!grouped[commodity]) {\n        grouped[commodity] = []\n      }\n      grouped[commodity].push({\n        date: result._id.date,\n        price: result.avgPrice,\n        volume: result.volume,\n        dataPoints: result.dataPoints\n      })\n    })\n    return grouped\n  }\n\n  analyzeTrends (trendsBycommodity) {\n    const analyzed = []\n    for (const [commodity, trends] of Object.entries(trendsBycommodity)) {\n      if (trends.length < 2) continue\n\n      const prices = trends.map(t => t.price)\n      const firstPrice = prices[0]\n      const lastPrice = prices[prices.length - 1]\n      const priceChange = lastPrice - firstPrice\n      const priceChangePercent = (priceChange / firstPrice) * 100\n\n      analyzed.push({\n        commodity,\n        dataPoints: trends,\n        analysis: {\n          priceChange: Math.round(priceChange),\n          priceChangePercent: Math.round(priceChangePercent * 100) / 100,\n          trend: priceChange > 0 ? 'rising' : priceChange < 0 ? 'falling' : 'stable',\n          volatility: this.calculateVolatility(prices),\n          avgPrice: Math.round(prices.reduce((a, b) => a + b, 0) / prices.length)\n        }\n      })\n    }\n    return analyzed\n  }\n\n  calculateVolatility (prices) {\n    if (prices.length < 2) return 0\n    const avg = prices.reduce((a, b) => a + b, 0) / prices.length\n    const variance = prices.reduce((sum, price) => sum + Math.pow(price - avg, 2), 0) / prices.length\n    return Math.round(Math.sqrt(variance))\n  }\n\n  async getStationInfo (systemName, stationName) {\n    // This would query station details from database\n    return {\n      type: 'Coriolis Starport',\n      services: ['Market', 'Shipyard', 'Outfitting', 'Repair'],\n      landingPadSize: 'Large',\n      distanceFromStar: 'Unknown'\n    }\n  }\n\n  calculateProfit (buyPrice, sellPrice) {\n    if (!buyPrice || !sellPrice) return 0\n    return Math.max(0, sellPrice - buyPrice)\n  }\n\n  calculateFreshness (timestamp) {\n    const ageMs = Date.now() - new Date(timestamp).getTime()\n    const ageHours = ageMs / (1000 * 60 * 60)\n\n    if (ageHours < 1) return 'Fresh'\n    if (ageHours < 6) return 'Recent'\n    if (ageHours < 24) return 'Moderate'\n    return 'Stale'\n  }\n}\n\nmodule.exports = MarketDataService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\miningOptimizer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\mongoService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\performanceOptimizer.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'currentUsage' is defined but never used. Allowed unused args must match /^_/u.","line":427,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":427,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Elite Dangerous Mining Data Server - Performance Optimization Manager\n * Comprehensive performance monitoring, caching optimization, and database tuning\n */\n\nconst logger = require('../services/logger')\n\nclass PerformanceOptimizer {\n  constructor (config = {}) {\n    this.config = {\n      // Cache optimization settings\n      cacheDefaults: {\n        ttl: 300, // 5 minutes default TTL\n        maxSize: 1000, // Maximum cache entries\n        compression: true,\n        encryptSensitive: false\n      },\n\n      // Database optimization settings\n      dbOptimization: {\n        indexHints: true,\n        queryOptimization: true,\n        connectionPooling: true,\n        bulkOperations: true\n      },\n\n      // API performance settings\n      apiOptimization: {\n        compression: true,\n        etags: true,\n        responseStreaming: true,\n        resultPagination: true\n      },\n\n      // Memory management\n      memoryManagement: {\n        gcOptimization: true,\n        memoryLeakDetection: true,\n        heapSnapshots: false\n      },\n\n      ...config\n    }\n\n    this.performanceMetrics = {\n      requests: new Map(),\n      cache: {\n        hits: 0,\n        misses: 0,\n        evictions: 0\n      },\n      database: {\n        connections: 0,\n        queries: 0,\n        slowQueries: []\n      },\n      memory: {\n        usage: [],\n        gc: []\n      }\n    }\n\n    this.optimization_recommendations = []\n  }\n\n  /**\n   * Initialize performance monitoring and optimization\n   */\n  async initialize () {\n    try {\n      logger.info('Initializing Performance Optimizer')\n\n      // Set up performance monitoring\n      this.setupPerformanceMonitoring()\n\n      // Initialize cache optimization\n      this.initializeCacheOptimization()\n\n      // Setup database optimization\n      this.setupDatabaseOptimization()\n\n      // Enable memory management\n      this.enableMemoryManagement()\n\n      logger.info('Performance Optimizer initialized successfully')\n\n      return {\n        success: true,\n        message: 'Performance optimization enabled',\n        features: Object.keys(this.config)\n      }\n    } catch (error) {\n      logger.error('Performance Optimizer initialization failed', { error: error.message })\n      throw error\n    }\n  }\n\n  /**\n   * Setup comprehensive performance monitoring\n   */\n  setupPerformanceMonitoring () {\n    // Request performance tracking\n    this.requestPerformanceMiddleware = (req, res, next) => {\n      const startTime = process.hrtime.bigint()\n      const startMemory = process.memoryUsage()\n\n      res.on('finish', () => {\n        const endTime = process.hrtime.bigint()\n        const endMemory = process.memoryUsage()\n\n        const duration = Number(endTime - startTime) / 1000000 // Convert to milliseconds\n        const memoryDelta = endMemory.heapUsed - startMemory.heapUsed\n\n        const performanceData = {\n          method: req.method,\n          path: req.path,\n          statusCode: res.statusCode,\n          duration,\n          memoryDelta,\n          timestamp: new Date(),\n          userAgent: req.get('User-Agent'),\n          contentLength: res.get('Content-Length')\n        }\n\n        // Store performance data\n        this.recordRequestPerformance(performanceData)\n\n        // Check for slow requests (> 1000ms)\n        if (duration > 1000) {\n          this.recordSlowRequest(performanceData)\n        }\n      })\n\n      next()\n    }\n\n    // System performance monitoring\n    setInterval(() => {\n      this.collectSystemMetrics()\n    }, 30000) // Every 30 seconds\n\n    logger.info('Performance monitoring enabled')\n  }\n\n  /**\n   * Initialize intelligent caching optimization\n   */\n  initializeCacheOptimization () {\n    this.cacheStrategies = {\n      // Time-based cache optimization\n      adaptiveTTL: (endpoint, usage) => {\n        const baseTime = this.config.cacheDefaults.ttl\n        const usageMultiplier = Math.min(usage.frequency / 10, 3) // Max 3x multiplier\n        return Math.floor(baseTime * (1 + usageMultiplier))\n      },\n\n      // Size-based cache optimization\n      intelligentEviction: (cacheStats) => {\n        // Prioritize keeping frequently accessed, recently used items\n        return cacheStats.entries\n          .sort((a, b) => {\n            const scoreA = (a.hits * 0.7) + (a.recency * 0.3)\n            const scoreB = (b.hits * 0.7) + (b.recency * 0.3)\n            return scoreB - scoreA\n          })\n          .slice(0, this.config.cacheDefaults.maxSize)\n      },\n\n      // Predictive pre-caching\n      predictiveCache: (accessPatterns) => {\n        const predictions = []\n\n        // Analyze access patterns to predict likely next requests\n        accessPatterns.forEach(pattern => {\n          if (pattern.frequency > 5 && pattern.timeSinceLastAccess < 3600) {\n            predictions.push({\n              endpoint: pattern.endpoint,\n              probability: this.calculateCacheProbability(pattern),\n              suggestedAction: 'preload'\n            })\n          }\n        })\n\n        return predictions\n      }\n    }\n\n    logger.info('Cache optimization strategies initialized')\n  }\n\n  /**\n   * Setup database performance optimization\n   */\n  setupDatabaseOptimization () {\n    this.databaseOptimizations = {\n      // Query optimization\n      optimizeQuery: (query, collection) => {\n        const optimizations = []\n\n        // Suggest indexes for common query patterns\n        if (query.filter) {\n          Object.keys(query.filter).forEach(field => {\n            optimizations.push({\n              type: 'index',\n              field,\n              collection,\n              impact: 'high',\n              reason: 'Frequent filter field'\n            })\n          })\n        }\n\n        // Suggest compound indexes for sort + filter\n        if (query.sort && query.filter) {\n          const sortFields = Object.keys(query.sort)\n          const filterFields = Object.keys(query.filter)\n\n          optimizations.push({\n            type: 'compound_index',\n            fields: [...filterFields, ...sortFields],\n            collection,\n            impact: 'medium',\n            reason: 'Sort and filter combination'\n          })\n        }\n\n        return optimizations\n      },\n\n      // Connection pool optimization\n      optimizeConnectionPool: (currentLoad) => {\n        const recommendations = []\n\n        if (currentLoad.activeConnections / currentLoad.maxConnections > 0.8) {\n          recommendations.push({\n            type: 'increase_pool_size',\n            current: currentLoad.maxConnections,\n            suggested: Math.min(currentLoad.maxConnections * 1.5, 100),\n            reason: 'High connection utilization'\n          })\n        }\n\n        if (currentLoad.avgWaitTime > 100) {\n          recommendations.push({\n            type: 'optimize_queries',\n            avgWaitTime: currentLoad.avgWaitTime,\n            reason: 'Long connection wait times'\n          })\n        }\n\n        return recommendations\n      },\n\n      // Bulk operation optimization\n      optimizeBulkOperations: (operations) => {\n        const batches = []\n        const batchSize = 1000 // Optimal batch size for MongoDB\n\n        for (let i = 0; i < operations.length; i += batchSize) {\n          batches.push(operations.slice(i, i + batchSize))\n        }\n\n        return {\n          originalCount: operations.length,\n          batchCount: batches.length,\n          batchSize,\n          estimatedImprovement: '60-80% faster'\n        }\n      }\n    }\n\n    logger.info('Database optimization strategies configured')\n  }\n\n  /**\n   * Enable memory management and leak detection\n   */\n  enableMemoryManagement () {\n    if (this.config.memoryManagement.gcOptimization) {\n      // Optimize garbage collection\n      this.gcOptimization = {\n        // Force GC during low activity periods\n        scheduleGC: () => {\n          if (global.gc && this.isLowActivityPeriod()) {\n            global.gc()\n            logger.debug('Forced garbage collection during low activity')\n          }\n        },\n\n        // Monitor memory growth\n        monitorMemoryGrowth: () => {\n          const usage = process.memoryUsage()\n          this.performanceMetrics.memory.usage.push({\n            timestamp: new Date(),\n            heapUsed: usage.heapUsed,\n            heapTotal: usage.heapTotal,\n            external: usage.external,\n            rss: usage.rss\n          })\n\n          // Keep only last 100 measurements\n          if (this.performanceMetrics.memory.usage.length > 100) {\n            this.performanceMetrics.memory.usage.shift()\n          }\n\n          // Detect potential memory leaks\n          this.detectMemoryLeaks(usage)\n        }\n      }\n\n      // Run memory monitoring every minute\n      setInterval(() => {\n        this.gcOptimization.monitorMemoryGrowth()\n      }, 60000)\n    }\n\n    logger.info('Memory management enabled')\n  }\n\n  /**\n   * Record request performance data\n   */\n  recordRequestPerformance (data) {\n    const key = `${data.method}:${data.path}`\n\n    if (!this.performanceMetrics.requests.has(key)) {\n      this.performanceMetrics.requests.set(key, {\n        count: 0,\n        totalDuration: 0,\n        avgDuration: 0,\n        minDuration: Infinity,\n        maxDuration: 0,\n        statusCodes: new Map(),\n        lastAccessed: null\n      })\n    }\n\n    const metrics = this.performanceMetrics.requests.get(key)\n    metrics.count++\n    metrics.totalDuration += data.duration\n    metrics.avgDuration = metrics.totalDuration / metrics.count\n    metrics.minDuration = Math.min(metrics.minDuration, data.duration)\n    metrics.maxDuration = Math.max(metrics.maxDuration, data.duration)\n    metrics.lastAccessed = data.timestamp\n\n    // Track status codes\n    const statusKey = data.statusCode.toString()\n    metrics.statusCodes.set(statusKey, (metrics.statusCodes.get(statusKey) || 0) + 1)\n  }\n\n  /**\n   * Record slow requests for analysis\n   */\n  recordSlowRequest (data) {\n    logger.warn('Slow request detected', {\n      endpoint: `${data.method} ${data.path}`,\n      duration: data.duration,\n      memoryDelta: data.memoryDelta\n    })\n\n    // Add to optimization recommendations\n    this.optimization_recommendations.push({\n      type: 'slow_endpoint',\n      endpoint: `${data.method} ${data.path}`,\n      duration: data.duration,\n      suggestion: 'Consider caching, query optimization, or code profiling',\n      priority: data.duration > 5000 ? 'high' : 'medium',\n      timestamp: data.timestamp\n    })\n  }\n\n  /**\n   * Collect system performance metrics\n   */\n  collectSystemMetrics () {\n    const cpuUsage = process.cpuUsage()\n    const memoryUsage = process.memoryUsage()\n\n    const metrics = {\n      timestamp: new Date(),\n      cpu: {\n        user: cpuUsage.user,\n        system: cpuUsage.system\n      },\n      memory: memoryUsage,\n      uptime: process.uptime(),\n      activeHandles: process._getActiveHandles().length,\n      activeRequests: process._getActiveRequests().length\n    }\n\n    // Check for performance issues\n    this.analyzeSystemPerformance(metrics)\n  }\n\n  /**\n   * Analyze system performance and generate recommendations\n   */\n  analyzeSystemPerformance (metrics) {\n    // Check memory usage\n    const memoryUsagePercent = (metrics.memory.heapUsed / metrics.memory.heapTotal) * 100\n\n    if (memoryUsagePercent > 80) {\n      this.optimization_recommendations.push({\n        type: 'high_memory_usage',\n        usage: memoryUsagePercent,\n        suggestion: 'Consider increasing heap size or optimizing memory usage',\n        priority: 'high',\n        timestamp: new Date()\n      })\n    }\n\n    // Check for too many active handles (potential memory leaks)\n    if (metrics.activeHandles > 1000) {\n      this.optimization_recommendations.push({\n        type: 'high_active_handles',\n        count: metrics.activeHandles,\n        suggestion: 'Check for unclosed connections or event listeners',\n        priority: 'medium',\n        timestamp: new Date()\n      })\n    }\n  }\n\n  /**\n   * Detect potential memory leaks\n   */\n  detectMemoryLeaks (currentUsage) {\n    const usageHistory = this.performanceMetrics.memory.usage\n\n    if (usageHistory.length >= 10) {\n      // Check if memory is consistently growing\n      const recent = usageHistory.slice(-10)\n      const older = usageHistory.slice(-20, -10)\n\n      const recentAvg = recent.reduce((sum, item) => sum + item.heapUsed, 0) / recent.length\n      const olderAvg = older.reduce((sum, item) => sum + item.heapUsed, 0) / older.length\n\n      const growthRate = (recentAvg - olderAvg) / olderAvg\n\n      if (growthRate > 0.1) { // 10% growth\n        this.optimization_recommendations.push({\n          type: 'potential_memory_leak',\n          growthRate: (growthRate * 100).toFixed(2),\n          suggestion: 'Investigate potential memory leaks in application code',\n          priority: 'high',\n          timestamp: new Date()\n        })\n      }\n    }\n  }\n\n  /**\n   * Calculate cache probability for predictive caching\n   */\n  calculateCacheProbability (pattern) {\n    const frequencyScore = Math.min(pattern.frequency / 20, 1) // Normalize to 0-1\n    const recencyScore = Math.max(0, 1 - (pattern.timeSinceLastAccess / 3600)) // Decay over hour\n    const timePatternScore = this.calculateTimePatternScore(pattern.accessTimes)\n\n    return (frequencyScore * 0.4) + (recencyScore * 0.4) + (timePatternScore * 0.2)\n  }\n\n  /**\n   * Calculate time pattern score for predictive caching\n   */\n  calculateTimePatternScore (accessTimes) {\n    if (!accessTimes || accessTimes.length < 3) return 0\n\n    // Check for regular intervals\n    const intervals = []\n    for (let i = 1; i < accessTimes.length; i++) {\n      intervals.push(accessTimes[i] - accessTimes[i - 1])\n    }\n\n    // Calculate standard deviation of intervals\n    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length\n    const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length\n    const stdDev = Math.sqrt(variance)\n\n    // Lower standard deviation = more regular pattern = higher score\n    return Math.max(0, 1 - (stdDev / avgInterval))\n  }\n\n  /**\n   * Check if current time is a low activity period\n   */\n  isLowActivityPeriod () {\n    const now = new Date()\n    const hour = now.getHours()\n\n    // Assume low activity between 2 AM and 6 AM\n    return hour >= 2 && hour <= 6\n  }\n\n  /**\n   * Get comprehensive performance report\n   */\n  getPerformanceReport () {\n    const requestMetrics = Array.from(this.performanceMetrics.requests.entries()).map(([endpoint, metrics]) => ({\n      endpoint,\n      ...metrics,\n      statusCodes: Object.fromEntries(metrics.statusCodes)\n    }))\n\n    // Sort by average duration (slowest first)\n    requestMetrics.sort((a, b) => b.avgDuration - a.avgDuration)\n\n    const memoryUsage = process.memoryUsage()\n    const cpuUsage = process.cpuUsage()\n\n    return {\n      timestamp: new Date().toISOString(),\n      summary: {\n        totalRequests: requestMetrics.reduce((sum, metric) => sum + metric.count, 0),\n        avgResponseTime: requestMetrics.reduce((sum, metric) => sum + metric.avgDuration, 0) / requestMetrics.length || 0,\n        cacheHitRatio: this.performanceMetrics.cache.hits / (this.performanceMetrics.cache.hits + this.performanceMetrics.cache.misses) || 0,\n        memoryUsage: (memoryUsage.heapUsed / memoryUsage.heapTotal * 100).toFixed(2) + '%'\n      },\n      endpoints: {\n        slowest: requestMetrics.slice(0, 10),\n        fastest: requestMetrics.slice(-10).reverse(),\n        mostFrequent: requestMetrics.sort((a, b) => b.count - a.count).slice(0, 10)\n      },\n      system: {\n        memory: memoryUsage,\n        cpu: cpuUsage,\n        uptime: process.uptime()\n      },\n      cache: this.performanceMetrics.cache,\n      recommendations: this.optimization_recommendations.slice(-20), // Last 20 recommendations\n      optimizationOpportunities: this.identifyOptimizationOpportunities()\n    }\n  }\n\n  /**\n   * Identify specific optimization opportunities\n   */\n  identifyOptimizationOpportunities () {\n    const opportunities = []\n\n    // Analyze request patterns for caching opportunities\n    const requestMetrics = Array.from(this.performanceMetrics.requests.entries())\n\n    requestMetrics.forEach(([endpoint, metrics]) => {\n      // High frequency, consistent response time = good cache candidate\n      if (metrics.count > 50 && (metrics.maxDuration - metrics.minDuration) / metrics.avgDuration < 0.5) {\n        opportunities.push({\n          type: 'caching',\n          endpoint,\n          impact: 'high',\n          description: `High frequency endpoint (${metrics.count} requests) with consistent response time`,\n          suggestion: 'Implement or optimize caching strategy'\n        })\n      }\n\n      // High response time variance = optimization needed\n      if ((metrics.maxDuration - metrics.minDuration) / metrics.avgDuration > 2) {\n        opportunities.push({\n          type: 'optimization',\n          endpoint,\n          impact: 'medium',\n          description: `High response time variance (${metrics.minDuration}ms - ${metrics.maxDuration}ms)`,\n          suggestion: 'Investigate and optimize slow code paths'\n        })\n      }\n    })\n\n    return opportunities\n  }\n\n  /**\n   * Apply automatic optimizations\n   */\n  async applyAutomaticOptimizations () {\n    const results = []\n\n    try {\n      // Apply cache optimizations\n      const cacheOptimizations = await this.applyCacheOptimizations()\n      results.push(...cacheOptimizations)\n\n      // Apply database optimizations\n      const dbOptimizations = await this.applyDatabaseOptimizations()\n      results.push(...dbOptimizations)\n\n      // Apply memory optimizations\n      const memoryOptimizations = this.applyMemoryOptimizations()\n      results.push(...memoryOptimizations)\n\n      logger.info('Automatic optimizations applied', {\n        count: results.length,\n        types: results.map(r => r.type)\n      })\n\n      return {\n        success: true,\n        optimizations: results,\n        timestamp: new Date().toISOString()\n      }\n    } catch (error) {\n      logger.error('Failed to apply automatic optimizations', { error: error.message })\n      throw error\n    }\n  }\n\n  /**\n   * Apply cache optimizations\n   */\n  async applyCacheOptimizations () {\n    const optimizations = []\n\n    // Implement adaptive TTL for frequently accessed endpoints\n    const requestMetrics = Array.from(this.performanceMetrics.requests.entries())\n\n    requestMetrics.forEach(([endpoint, metrics]) => {\n      if (metrics.count > 20) {\n        const usage = {\n          frequency: metrics.count,\n          avgDuration: metrics.avgDuration\n        }\n\n        const optimizedTTL = this.cacheStrategies.adaptiveTTL(endpoint, usage)\n\n        optimizations.push({\n          type: 'adaptive_ttl',\n          endpoint,\n          originalTTL: this.config.cacheDefaults.ttl,\n          optimizedTTL,\n          expectedImprovement: 'Reduced cache misses'\n        })\n      }\n    })\n\n    return optimizations\n  }\n\n  /**\n   * Apply database optimizations\n   */\n  async applyDatabaseOptimizations () {\n    const optimizations = []\n\n    // Generate index recommendations based on slow queries\n    // Note: This would integrate with actual database performance data\n\n    optimizations.push({\n      type: 'index_recommendation',\n      description: 'Recommended indexes based on query patterns',\n      implementation: 'Manual - see database optimization report'\n    })\n\n    return optimizations\n  }\n\n  /**\n   * Apply memory optimizations\n   */\n  applyMemoryOptimizations () {\n    const optimizations = []\n\n    // Force garbage collection if memory usage is high\n    const memoryUsage = process.memoryUsage()\n    const usagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100\n\n    if (usagePercent > 70 && global.gc) {\n      global.gc()\n      optimizations.push({\n        type: 'garbage_collection',\n        description: 'Forced garbage collection due to high memory usage',\n        beforeUsage: usagePercent,\n        afterUsage: (process.memoryUsage().heapUsed / process.memoryUsage().heapTotal) * 100\n      })\n    }\n\n    return optimizations\n  }\n}\n\nmodule.exports = PerformanceOptimizer\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\rateLimitService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'options' is assigned a value but never used.","line":180,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":180,"endColumn":44}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const logger = require('./logger')\n\n/**\n * Intelligent Rate Limiting Service\n * Manages rate limits across multiple external APIs with queue management,\n * adaptive throttling, and priority-based request handling\n */\nclass RateLimitService {\n  constructor (config = {}) {\n    this.globalConfig = {\n      defaultWindowMs: config.defaultWindowMs || 60000, // 1 minute\n      defaultMaxRequests: config.defaultMaxRequests || 100,\n      queueTimeout: config.queueTimeout || 30000, // 30 seconds\n      adaptiveThrottling: config.adaptiveThrottling !== false,\n      priorityLevels: config.priorityLevels || ['low', 'normal', 'high', 'critical']\n    }\n\n    // Service-specific rate limiters\n    this.services = new Map()\n\n    // Global request queue with priority support\n    this.requestQueue = {\n      critical: [],\n      high: [],\n      normal: [],\n      low: []\n    }\n\n    // Queue processing state\n    this.queueProcessor = {\n      isRunning: false,\n      processInterval: null,\n      processDelay: 100 // Base delay between queue processing\n    }\n\n    // Adaptive throttling state\n    this.adaptiveState = {\n      errorRates: new Map(),\n      responseTimers: new Map(),\n      throttleFactors: new Map()\n    }\n\n    // Global statistics\n    this.globalStats = {\n      totalRequests: 0,\n      totalQueued: 0,\n      totalTimedOut: 0,\n      totalErrors: 0,\n      averageWaitTime: 0,\n      peakQueueSize: 0\n    }\n\n    this.startQueueProcessor()\n    this.startAdaptiveThrottling()\n\n    logger.info('Rate Limiting Service initialized', {\n      defaultWindowMs: this.globalConfig.defaultWindowMs,\n      defaultMaxRequests: this.globalConfig.defaultMaxRequests,\n      adaptiveThrottling: this.globalConfig.adaptiveThrottling\n    })\n  }\n\n  /**\n   * Register a new service with specific rate limiting configuration\n   */\n  registerService (serviceName, config) {\n    const serviceConfig = {\n      maxRequests: config.maxRequests || this.globalConfig.defaultMaxRequests,\n      windowMs: config.windowMs || this.globalConfig.defaultWindowMs,\n      burstAllowance: config.burstAllowance || Math.floor(config.maxRequests * 0.2),\n      backoffMultiplier: config.backoffMultiplier || 1.5,\n      maxBackoffDelay: config.maxBackoffDelay || 60000,\n      priority: config.priority || 'normal'\n    }\n\n    this.services.set(serviceName, {\n      config: serviceConfig,\n      requestHistory: [],\n      burstTokens: serviceConfig.burstAllowance,\n      lastBurstRefill: Date.now(),\n      currentBackoffDelay: 0,\n      stats: {\n        totalRequests: 0,\n        throttledRequests: 0,\n        averageWaitTime: 0,\n        errorRate: 0,\n        lastRequestTime: null\n      }\n    })\n\n    // Initialize adaptive throttling state\n    this.adaptiveState.errorRates.set(serviceName, { errors: 0, total: 0 })\n    this.adaptiveState.responseTimers.set(serviceName, [])\n    this.adaptiveState.throttleFactors.set(serviceName, 1.0)\n\n    logger.info('Registered rate limiting service', { serviceName, config: serviceConfig })\n  }\n\n  /**\n   * Make a rate-limited request\n   */\n  async makeRequest (serviceName, requestFn, options = {}) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      throw new Error(`Service '${serviceName}' not registered with rate limiter`)\n    }\n\n    const priority = options.priority || service.config.priority\n    const timeout = options.timeout || this.globalConfig.queueTimeout\n\n    // Create request promise with timeout\n    return new Promise((resolve, reject) => {\n      const requestItem = {\n        serviceName,\n        requestFn,\n        options,\n        priority,\n        resolve,\n        reject,\n        createdAt: Date.now(),\n        timeout: setTimeout(() => {\n          this.removeFromQueue(requestItem)\n          this.globalStats.totalTimedOut++\n          reject(new Error(`Request timed out after ${timeout}ms`))\n        }, timeout)\n      }\n\n      // Add to appropriate priority queue\n      this.requestQueue[priority].push(requestItem)\n      this.globalStats.totalQueued++\n\n      // Update peak queue size\n      const currentQueueSize = this.getTotalQueueSize()\n      if (currentQueueSize > this.globalStats.peakQueueSize) {\n        this.globalStats.peakQueueSize = currentQueueSize\n      }\n\n      logger.debug('Request queued', {\n        serviceName,\n        priority,\n        queueSize: currentQueueSize,\n        position: this.requestQueue[priority].length\n      })\n    })\n  }\n\n  /**\n   * Check if request can be made immediately\n   */\n  canMakeRequest (serviceName) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      return false\n    }\n\n    const now = Date.now()\n    const adaptiveThrottleFactor = this.adaptiveState.throttleFactors.get(serviceName) || 1.0\n    const effectiveMaxRequests = Math.floor(service.config.maxRequests / adaptiveThrottleFactor)\n    const effectiveWindowMs = service.config.windowMs * adaptiveThrottleFactor\n\n    // Clean old requests from history\n    service.requestHistory = service.requestHistory.filter(\n      timestamp => now - timestamp < effectiveWindowMs\n    )\n\n    // Check burst tokens first\n    this.refillBurstTokens(service, now)\n    if (service.burstTokens > 0) {\n      return true\n    }\n\n    // Check regular rate limit\n    return service.requestHistory.length < effectiveMaxRequests\n  }\n\n  /**\n   * Execute a request if rate limit allows\n   */\n  async executeRequest (requestItem) {\n    const { serviceName, requestFn, options } = requestItem\n    const service = this.services.get(serviceName)\n\n    if (!this.canMakeRequest(serviceName)) {\n      return false // Cannot execute now, keep in queue\n    }\n\n    const startTime = Date.now()\n\n    try {\n      // Use burst token if available\n      if (service.burstTokens > 0) {\n        service.burstTokens--\n        logger.debug('Used burst token', { serviceName, tokensLeft: service.burstTokens })\n      }\n\n      // Record request in history\n      service.requestHistory.push(startTime)\n      service.stats.totalRequests++\n      service.stats.lastRequestTime = startTime\n      this.globalStats.totalRequests++\n\n      // Execute the actual request\n      const result = await requestFn()\n\n      // Record successful execution\n      const executionTime = Date.now() - startTime\n      this.updateAdaptiveThrottling(serviceName, executionTime, false)\n\n      // Update wait time statistics\n      const waitTime = startTime - requestItem.createdAt\n      this.updateWaitTimeStats(service, waitTime)\n\n      // Clear timeout and resolve\n      clearTimeout(requestItem.timeout)\n      requestItem.resolve(result)\n\n      logger.debug('Request executed successfully', {\n        serviceName,\n        executionTime,\n        waitTime\n      })\n\n      return true\n    } catch (error) {\n      // Record error for adaptive throttling\n      this.updateAdaptiveThrottling(serviceName, Date.now() - startTime, true)\n      this.globalStats.totalErrors++\n\n      // Update backoff delay\n      service.currentBackoffDelay = Math.min(\n        service.currentBackoffDelay * service.config.backoffMultiplier,\n        service.config.maxBackoffDelay\n      )\n\n      // Clear timeout and reject\n      clearTimeout(requestItem.timeout)\n      requestItem.reject(error)\n\n      logger.error('Request execution failed', {\n        serviceName,\n        error: error.message,\n        newBackoffDelay: service.currentBackoffDelay\n      })\n\n      return true // Remove from queue even on error\n    }\n  }\n\n  /**\n   * Refill burst tokens\n   */\n  refillBurstTokens (service, now) {\n    const timeSinceRefill = now - service.lastBurstRefill\n    const tokensToAdd = Math.floor(timeSinceRefill / (service.config.windowMs / service.config.burstAllowance))\n\n    if (tokensToAdd > 0) {\n      service.burstTokens = Math.min(\n        service.burstTokens + tokensToAdd,\n        service.config.burstAllowance\n      )\n      service.lastBurstRefill = now\n    }\n  }\n\n  /**\n   * Update wait time statistics\n   */\n  updateWaitTimeStats (service, waitTime) {\n    const currentAvg = service.stats.averageWaitTime\n    const totalRequests = service.stats.totalRequests\n\n    service.stats.averageWaitTime = (currentAvg * (totalRequests - 1) + waitTime) / totalRequests\n\n    // Update global average\n    const globalAvg = this.globalStats.averageWaitTime\n    const globalTotal = this.globalStats.totalRequests\n    this.globalStats.averageWaitTime = (globalAvg * (globalTotal - 1) + waitTime) / globalTotal\n  }\n\n  /**\n   * Update adaptive throttling based on response time and errors\n   */\n  updateAdaptiveThrottling (serviceName, responseTime, isError) {\n    if (!this.globalConfig.adaptiveThrottling) {\n      return\n    }\n\n    // Update error rate\n    const errorData = this.adaptiveState.errorRates.get(serviceName)\n    errorData.total++\n    if (isError) {\n      errorData.errors++\n    }\n\n    // Update response time history\n    const responseTimes = this.adaptiveState.responseTimers.get(serviceName)\n    responseTimes.push(responseTime)\n    if (responseTimes.length > 100) {\n      responseTimes.shift() // Keep only last 100 responses\n    }\n\n    // Calculate new throttle factor\n    let throttleFactor = 1.0\n\n    // Increase throttling based on error rate\n    const errorRate = errorData.errors / errorData.total\n    if (errorRate > 0.1) { // 10% error rate\n      throttleFactor *= 1 + (errorRate - 0.1) * 2 // Increase throttling\n    }\n\n    // Increase throttling based on slow response times\n    if (responseTimes.length >= 10) {\n      const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length\n      if (avgResponseTime > 5000) { // 5+ seconds average\n        throttleFactor *= 1 + ((avgResponseTime - 5000) / 10000) // Gradual increase\n      }\n    }\n\n    // Apply throttle factor with smoothing\n    const currentFactor = this.adaptiveState.throttleFactors.get(serviceName)\n    const smoothedFactor = currentFactor * 0.9 + throttleFactor * 0.1\n    this.adaptiveState.throttleFactors.set(serviceName, Math.max(1.0, smoothedFactor))\n\n    logger.debug('Updated adaptive throttling', {\n      serviceName,\n      errorRate,\n      avgResponseTime: responseTimes.length ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0,\n      throttleFactor: smoothedFactor\n    })\n  }\n\n  /**\n   * Process request queue with priority handling\n   */\n  async processQueue () {\n    if (this.queueProcessor.isRunning) {\n      return\n    }\n\n    this.queueProcessor.isRunning = true\n\n    try {\n      // Process requests by priority order\n      for (const priority of this.globalConfig.priorityLevels.reverse()) {\n        const queue = this.requestQueue[priority]\n\n        while (queue.length > 0) {\n          const requestItem = queue.shift()\n\n          // Check if request has timed out\n          if (Date.now() - requestItem.createdAt > this.globalConfig.queueTimeout) {\n            clearTimeout(requestItem.timeout)\n            requestItem.reject(new Error('Request timed out in queue'))\n            this.globalStats.totalTimedOut++\n            continue\n          }\n\n          // Try to execute request\n          const executed = await this.executeRequest(requestItem)\n          if (!executed) {\n            // Put back at front of queue if couldn't execute\n            queue.unshift(requestItem)\n            break // Try again later\n          }\n\n          // Add delay to prevent overwhelming\n          await this.sleep(this.queueProcessor.processDelay)\n        }\n      }\n    } catch (error) {\n      logger.error('Error processing request queue', { error: error.message })\n    } finally {\n      this.queueProcessor.isRunning = false\n    }\n  }\n\n  /**\n   * Remove request from queue\n   */\n  removeFromQueue (requestItem) {\n    const priority = requestItem.priority\n    const queue = this.requestQueue[priority]\n    const index = queue.indexOf(requestItem)\n    if (index !== -1) {\n      queue.splice(index, 1)\n    }\n  }\n\n  /**\n   * Get total queue size across all priorities\n   */\n  getTotalQueueSize () {\n    return Object.values(this.requestQueue).reduce((total, queue) => total + queue.length, 0)\n  }\n\n  /**\n   * Start queue processor\n   */\n  startQueueProcessor () {\n    this.queueProcessor.processInterval = setInterval(() => {\n      if (this.getTotalQueueSize() > 0) {\n        this.processQueue()\n      }\n    }, this.queueProcessor.processDelay)\n\n    logger.info('Queue processor started')\n  }\n\n  /**\n   * Start adaptive throttling cleanup\n   */\n  startAdaptiveThrottling () {\n    // Reset error rates periodically\n    setInterval(() => {\n      for (const [serviceName, errorData] of this.adaptiveState.errorRates) {\n        // Decay error rate gradually\n        errorData.errors = Math.floor(errorData.errors * 0.95)\n        errorData.total = Math.floor(errorData.total * 0.95)\n\n        // Reset throttle factor gradually\n        const currentFactor = this.adaptiveState.throttleFactors.get(serviceName)\n        const newFactor = currentFactor * 0.99 // Gradual recovery\n        this.adaptiveState.throttleFactors.set(serviceName, Math.max(1.0, newFactor))\n      }\n    }, 30000) // Every 30 seconds\n  }\n\n  /**\n   * Utility sleep function\n   */\n  sleep (ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Get service statistics\n   */\n  getServiceStats (serviceName) {\n    const service = this.services.get(serviceName)\n    if (!service) {\n      return null\n    }\n\n    const adaptiveState = {\n      throttleFactor: this.adaptiveState.throttleFactors.get(serviceName),\n      errorRate: this.adaptiveState.errorRates.get(serviceName),\n      avgResponseTime: this.adaptiveState.responseTimers.get(serviceName).length\n        ? this.adaptiveState.responseTimers.get(serviceName).reduce((a, b) => a + b, 0) / this.adaptiveState.responseTimers.get(serviceName).length\n        : 0\n    }\n\n    return {\n      serviceName,\n      config: service.config,\n      stats: service.stats,\n      adaptiveState,\n      currentState: {\n        requestsInWindow: service.requestHistory.length,\n        burstTokens: service.burstTokens,\n        backoffDelay: service.currentBackoffDelay,\n        canMakeRequest: this.canMakeRequest(serviceName)\n      }\n    }\n  }\n\n  /**\n   * Get global statistics\n   */\n  getGlobalStats () {\n    return {\n      ...this.globalStats,\n      services: this.services.size,\n      currentQueueSize: this.getTotalQueueSize(),\n      queueByPriority: Object.fromEntries(\n        Object.entries(this.requestQueue).map(([priority, queue]) => [priority, queue.length])\n      ),\n      adaptiveThrottling: this.globalConfig.adaptiveThrottling,\n      processorRunning: this.queueProcessor.isRunning\n    }\n  }\n\n  /**\n   * Get health status\n   */\n  getHealthStatus () {\n    const totalQueueSize = this.getTotalQueueSize()\n    const errorRate = this.globalStats.totalRequests > 0\n      ? this.globalStats.totalErrors / this.globalStats.totalRequests\n      : 0\n\n    let status = 'healthy'\n    if (totalQueueSize > 100 || errorRate > 0.1) {\n      status = 'degraded'\n    }\n    if (totalQueueSize > 500 || errorRate > 0.3) {\n      status = 'unhealthy'\n    }\n\n    return {\n      service: 'Rate Limiting Service',\n      status,\n      totalQueueSize,\n      errorRate,\n      averageWaitTime: this.globalStats.averageWaitTime,\n      registeredServices: this.services.size,\n      adaptiveThrottling: this.globalConfig.adaptiveThrottling\n    }\n  }\n\n  /**\n   * Cleanup and shutdown\n   */\n  shutdown () {\n    if (this.queueProcessor.processInterval) {\n      clearInterval(this.queueProcessor.processInterval)\n      this.queueProcessor.processInterval = null\n    }\n\n    // Reject all pending requests\n    for (const priority in this.requestQueue) {\n      const queue = this.requestQueue[priority]\n      while (queue.length > 0) {\n        const requestItem = queue.shift()\n        clearTimeout(requestItem.timeout)\n        requestItem.reject(new Error('Rate limiting service is shutting down'))\n      }\n    }\n\n    logger.info('Rate Limiting Service shut down')\n  }\n}\n\nmodule.exports = RateLimitService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]},{"filePath":"X:\\Github Workspace\\Elite Dangerous\\EliteMiningDataServer\\src\\services\\redisCacheService.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'type' is assigned a value but never used.","line":455,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":455,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Redis Cache Service for Elite Mining Data Server\n * Distributed caching with invalidation strategies and performance optimization\n */\n\nconst redis = require('redis')\nconst logger = require('../services/logger')\n\nclass RedisCacheService {\n  constructor (config = {}) {\n    this.config = {\n      host: config.host || process.env.REDIS_HOST || 'localhost',\n      port: config.port || process.env.REDIS_PORT || 6379,\n      password: config.password || process.env.REDIS_PASSWORD,\n      db: config.db || process.env.REDIS_DB || 0,\n      keyPrefix: config.keyPrefix || 'elite_mining:',\n      defaultTTL: config.defaultTTL || 300, // 5 minutes\n      maxRetries: config.maxRetries || 3,\n      retryDelayOnFailover: config.retryDelayOnFailover || 100,\n      enableReadyCheck: true,\n      maxRetriesPerRequest: 3\n    }\n\n    this.client = null\n    this.subscriber = null\n    this.isConnected = false\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      errors: 0\n    }\n  }\n\n  /**\n   * Initialize Redis connection\n   */\n  async initialize () {\n    try {\n      // Create main Redis client\n      this.client = redis.createClient({\n        socket: {\n          host: this.config.host,\n          port: this.config.port\n        },\n        password: this.config.password,\n        database: this.config.db,\n        name: 'elite_mining_cache'\n      })\n\n      // Create subscriber client for cache invalidation\n      this.subscriber = redis.createClient({\n        socket: {\n          host: this.config.host,\n          port: this.config.port\n        },\n        password: this.config.password,\n        database: this.config.db,\n        name: 'elite_mining_subscriber'\n      })\n\n      // Set up event handlers\n      this.setupEventHandlers()\n\n      // Connect to Redis\n      await this.client.connect()\n      await this.subscriber.connect()\n\n      this.isConnected = true\n      logger.info('Redis Cache Service initialized successfully')\n\n      // Set up cache invalidation subscriptions\n      await this.setupCacheInvalidation()\n\n      return { status: 'connected', config: this.config }\n    } catch (error) {\n      logger.error('Failed to initialize Redis Cache Service:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Set up Redis event handlers\n   */\n  setupEventHandlers () {\n    this.client.on('error', (error) => {\n      logger.error('Redis Client Error:', error)\n      this.stats.errors++\n      this.isConnected = false\n    })\n\n    this.client.on('connect', () => {\n      logger.info('Redis Client Connected')\n      this.isConnected = true\n    })\n\n    this.client.on('reconnecting', () => {\n      logger.warn('Redis Client Reconnecting')\n      this.isConnected = false\n    })\n\n    this.client.on('end', () => {\n      logger.warn('Redis Client Connection Ended')\n      this.isConnected = false\n    })\n\n    this.subscriber.on('error', (error) => {\n      logger.error('Redis Subscriber Error:', error)\n    })\n  }\n\n  /**\n   * Set up cache invalidation subscriptions\n   */\n  async setupCacheInvalidation () {\n    // Subscribe to market data updates\n    await this.subscriber.subscribe('market_data_update', (message) => {\n      this.handleMarketDataInvalidation(JSON.parse(message))\n    })\n\n    // Subscribe to mining data updates\n    await this.subscriber.subscribe('mining_data_update', (message) => {\n      this.handleMiningDataInvalidation(JSON.parse(message))\n    })\n\n    // Subscribe to statistics updates\n    await this.subscriber.subscribe('statistics_update', (message) => {\n      this.handleStatisticsInvalidation(JSON.parse(message))\n    })\n\n    logger.info('Cache invalidation subscriptions set up')\n  }\n\n  /**\n   * Get data from cache\n   */\n  async get (key) {\n    if (!this.isConnected) {\n      return null\n    }\n\n    try {\n      const fullKey = this.getFullKey(key)\n      const value = await this.client.get(fullKey)\n\n      if (value) {\n        this.stats.hits++\n        return JSON.parse(value)\n      } else {\n        this.stats.misses++\n        return null\n      }\n    } catch (error) {\n      logger.error('Redis GET error:', error)\n      this.stats.errors++\n      return null\n    }\n  }\n\n  /**\n   * Set data in cache\n   */\n  async set (key, value, ttl = null) {\n    if (!this.isConnected) {\n      return false\n    }\n\n    try {\n      const fullKey = this.getFullKey(key)\n      const serializedValue = JSON.stringify(value)\n      const cacheTTL = ttl || this.config.defaultTTL\n\n      await this.client.setEx(fullKey, cacheTTL, serializedValue)\n      this.stats.sets++\n      return true\n    } catch (error) {\n      logger.error('Redis SET error:', error)\n      this.stats.errors++\n      return false\n    }\n  }\n\n  /**\n   * Delete data from cache\n   */\n  async del (key) {\n    if (!this.isConnected) {\n      return false\n    }\n\n    try {\n      const fullKey = this.getFullKey(key)\n      const result = await this.client.del(fullKey)\n      this.stats.deletes++\n      return result > 0\n    } catch (error) {\n      logger.error('Redis DEL error:', error)\n      this.stats.errors++\n      return false\n    }\n  }\n\n  /**\n   * Delete multiple keys by pattern\n   */\n  async delPattern (pattern) {\n    if (!this.isConnected) {\n      return 0\n    }\n\n    try {\n      const fullPattern = this.getFullKey(pattern)\n      const keys = await this.client.keys(fullPattern)\n\n      if (keys.length > 0) {\n        const result = await this.client.del(keys)\n        this.stats.deletes += keys.length\n        return result\n      }\n\n      return 0\n    } catch (error) {\n      logger.error('Redis DEL pattern error:', error)\n      this.stats.errors++\n      return 0\n    }\n  }\n\n  /**\n   * Check if key exists\n   */\n  async exists (key) {\n    if (!this.isConnected) {\n      return false\n    }\n\n    try {\n      const fullKey = this.getFullKey(key)\n      const result = await this.client.exists(fullKey)\n      return result === 1\n    } catch (error) {\n      logger.error('Redis EXISTS error:', error)\n      this.stats.errors++\n      return false\n    }\n  }\n\n  /**\n   * Get TTL for key\n   */\n  async ttl (key) {\n    if (!this.isConnected) {\n      return -1\n    }\n\n    try {\n      const fullKey = this.getFullKey(key)\n      return await this.client.ttl(fullKey)\n    } catch (error) {\n      logger.error('Redis TTL error:', error)\n      this.stats.errors++\n      return -1\n    }\n  }\n\n  /**\n   * Cache market data with specific TTL based on data type\n   */\n  async cacheMarketData (type, key, data, system = null) {\n    const cacheKey = this.buildMarketCacheKey(type, key, system)\n    const ttl = this.getMarketDataTTL(type)\n\n    // Add metadata for invalidation\n    const cacheData = {\n      ...data,\n      _cached_at: new Date().toISOString(),\n      _cache_type: 'market_data',\n      _cache_key: cacheKey\n    }\n\n    return await this.set(cacheKey, cacheData, ttl)\n  }\n\n  /**\n   * Get market data from cache\n   */\n  async getMarketData (type, key, system = null) {\n    const cacheKey = this.buildMarketCacheKey(type, key, system)\n    const data = await this.get(cacheKey)\n\n    if (data && this.isMarketDataFresh(data, type)) {\n      return data\n    }\n\n    // Data is stale, remove from cache\n    if (data) {\n      await this.del(cacheKey)\n    }\n\n    return null\n  }\n\n  /**\n   * Cache statistics data\n   */\n  async cacheStatistics (type, data, filters = {}) {\n    const cacheKey = this.buildStatsCacheKey(type, filters)\n    const ttl = this.getStatisticsTTL(type)\n\n    const cacheData = {\n      ...data,\n      _cached_at: new Date().toISOString(),\n      _cache_type: 'statistics',\n      _cache_key: cacheKey\n    }\n\n    return await this.set(cacheKey, cacheData, ttl)\n  }\n\n  /**\n   * Get statistics from cache\n   */\n  async getStatistics (type, filters = {}) {\n    const cacheKey = this.buildStatsCacheKey(type, filters)\n    return await this.get(cacheKey)\n  }\n\n  /**\n   * Cache mining data\n   */\n  async cacheMiningData (type, data, filters = {}) {\n    const cacheKey = this.buildMiningCacheKey(type, filters)\n    const ttl = this.getMiningDataTTL(type)\n\n    const cacheData = {\n      ...data,\n      _cached_at: new Date().toISOString(),\n      _cache_type: 'mining_data',\n      _cache_key: cacheKey\n    }\n\n    return await this.set(cacheKey, cacheData, ttl)\n  }\n\n  /**\n   * Get mining data from cache\n   */\n  async getMiningData (type, filters = {}) {\n    const cacheKey = this.buildMiningCacheKey(type, filters)\n    return await this.get(cacheKey)\n  }\n\n  /**\n   * Build market data cache key\n   */\n  buildMarketCacheKey (type, key, system) {\n    const parts = ['market', type, key]\n    if (system) {\n      parts.push(system)\n    }\n    return parts.join(':')\n  }\n\n  /**\n   * Build statistics cache key\n   */\n  buildStatsCacheKey (type, filters) {\n    const filterHash = this.hashFilters(filters)\n    return `stats:${type}:${filterHash}`\n  }\n\n  /**\n   * Build mining data cache key\n   */\n  buildMiningCacheKey (type, filters) {\n    const filterHash = this.hashFilters(filters)\n    return `mining:${type}:${filterHash}`\n  }\n\n  /**\n   * Hash filters for cache key\n   */\n  hashFilters (filters) {\n    const crypto = require('crypto')\n    const filterString = JSON.stringify(filters, Object.keys(filters).sort())\n    return crypto.createHash('md5').update(filterString).digest('hex').substring(0, 8)\n  }\n\n  /**\n   * Get TTL for market data based on type\n   */\n  getMarketDataTTL (type) {\n    const ttls = {\n      commodity: 300, // 5 minutes\n      routes: 600, // 10 minutes\n      trends: 1800, // 30 minutes\n      station: 300, // 5 minutes\n      system_summary: 900 // 15 minutes\n    }\n    return ttls[type] || this.config.defaultTTL\n  }\n\n  /**\n   * Get TTL for statistics based on type\n   */\n  getStatisticsTTL (type) {\n    const ttls = {\n      global: 600, // 10 minutes\n      eddn: 120, // 2 minutes\n      mining: 1800, // 30 minutes\n      api_usage: 300, // 5 minutes\n      websocket: 60 // 1 minute\n    }\n    return ttls[type] || this.config.defaultTTL\n  }\n\n  /**\n   * Get TTL for mining data based on type\n   */\n  getMiningDataTTL (type) {\n    const ttls = {\n      profitability: 1800, // 30 minutes\n      hotspots: 3600, // 1 hour\n      locations: 900 // 15 minutes\n    }\n    return ttls[type] || this.config.defaultTTL\n  }\n\n  /**\n   * Check if market data is still fresh\n   */\n  isMarketDataFresh (data, type) {\n    if (!data._cached_at) return false\n\n    const cachedAt = new Date(data._cached_at)\n    const now = new Date()\n    const ageMinutes = (now - cachedAt) / (1000 * 60)\n\n    const freshnessThresholds = {\n      commodity: 5,\n      routes: 10,\n      trends: 30,\n      station: 5\n    }\n\n    const threshold = freshnessThresholds[type] || 5\n    return ageMinutes < threshold\n  }\n\n  /**\n   * Handle market data invalidation\n   */\n  async handleMarketDataInvalidation (message) {\n    const { commodity, system, station, type } = message\n\n    const patterns = []\n\n    if (commodity) {\n      patterns.push(`market:commodity:${commodity}*`)\n      patterns.push(`market:trends:${commodity}*`)\n    }\n\n    if (system) {\n      patterns.push(`market:*:*:${system}`)\n      patterns.push(`market:system_summary:${system}`)\n    }\n\n    if (station) {\n      patterns.push(`market:station:${system}:${station}`)\n    }\n\n    // Invalidate routes that might be affected\n    if (commodity || system) {\n      patterns.push('market:routes:*')\n    }\n\n    for (const pattern of patterns) {\n      await this.delPattern(pattern)\n    }\n\n    logger.info(`Invalidated market cache for: ${JSON.stringify(message)}`)\n  }\n\n  /**\n   * Handle mining data invalidation\n   */\n  async handleMiningDataInvalidation (message) {\n    const { location, commodity, system } = message\n\n    const patterns = []\n\n    if (location) {\n      patterns.push(`mining:*:*${location}*`)\n    }\n\n    if (commodity) {\n      patterns.push(`mining:profitability:*${commodity}*`)\n    }\n\n    if (system) {\n      patterns.push(`mining:*:*${system}*`)\n    }\n\n    for (const pattern of patterns) {\n      await this.delPattern(pattern)\n    }\n\n    logger.info(`Invalidated mining cache for: ${JSON.stringify(message)}`)\n  }\n\n  /**\n   * Handle statistics invalidation\n   */\n  async handleStatisticsInvalidation (message) {\n    const { type, scope } = message\n\n    if (scope === 'all') {\n      await this.delPattern('stats:*')\n    } else if (type) {\n      await this.delPattern(`stats:${type}:*`)\n    }\n\n    logger.info(`Invalidated statistics cache for: ${JSON.stringify(message)}`)\n  }\n\n  /**\n   * Publish cache invalidation message\n   */\n  async publishInvalidation (channel, message) {\n    if (!this.isConnected) {\n      return false\n    }\n\n    try {\n      await this.client.publish(channel, JSON.stringify(message))\n      return true\n    } catch (error) {\n      logger.error('Failed to publish invalidation message:', error)\n      return false\n    }\n  }\n\n  /**\n   * Warm up cache with frequently accessed data\n   */\n  async warmupCache () {\n    logger.info('Starting cache warmup...')\n\n    try {\n      // This would typically load frequently accessed data\n      // Implementation depends on your specific use cases\n\n      // Example: Pre-load popular commodities\n      const popularCommodities = ['Gold', 'Painite', 'Void Opals', 'Low Temperature Diamonds']\n\n      for (const commodity of popularCommodities) {\n        // Pre-load recent market data for popular commodities\n        // This would call your market data service and cache the results\n        logger.info(`Warming up cache for commodity: ${commodity}`)\n      }\n\n      logger.info('Cache warmup completed')\n      return true\n    } catch (error) {\n      logger.error('Cache warmup failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats () {\n    const hitRate = this.stats.hits + this.stats.misses > 0\n      ? (this.stats.hits / (this.stats.hits + this.stats.misses)) * 100\n      : 0\n\n    return {\n      ...this.stats,\n      hitRate: Math.round(hitRate * 100) / 100,\n      isConnected: this.isConnected,\n      config: {\n        host: this.config.host,\n        port: this.config.port,\n        db: this.config.db,\n        keyPrefix: this.config.keyPrefix\n      }\n    }\n  }\n\n  /**\n   * Clear all cache data\n   */\n  async clearCache () {\n    if (!this.isConnected) {\n      return false\n    }\n\n    try {\n      await this.client.flushDb()\n      logger.info('Cache cleared successfully')\n      return true\n    } catch (error) {\n      logger.error('Failed to clear cache:', error)\n      return false\n    }\n  }\n\n  /**\n   * Get full cache key with prefix\n   */\n  getFullKey (key) {\n    return `${this.config.keyPrefix}${key}`\n  }\n\n  /**\n   * Health check for Redis service\n   */\n  async healthCheck () {\n    try {\n      if (!this.isConnected) {\n        return { status: 'unhealthy', message: 'Redis not connected' }\n      }\n\n      const ping = await this.client.ping()\n      if (ping === 'PONG') {\n        return {\n          status: 'healthy',\n          stats: this.getCacheStats(),\n          timestamp: new Date().toISOString()\n        }\n      } else {\n        return { status: 'unhealthy', message: 'Redis ping failed' }\n      }\n    } catch (error) {\n      return { status: 'unhealthy', message: error.message }\n    }\n  }\n\n  /**\n   * Gracefully close Redis connections\n   */\n  async close () {\n    try {\n      if (this.client) {\n        await this.client.quit()\n      }\n      if (this.subscriber) {\n        await this.subscriber.quit()\n      }\n      this.isConnected = false\n      logger.info('Redis Cache Service closed')\n    } catch (error) {\n      logger.error('Error closing Redis connections:', error)\n    }\n  }\n}\n\nmodule.exports = RedisCacheService\n","usedDeprecatedRules":[{"ruleId":"array-bracket-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"block-spacing","replacedBy":[]},{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"comma-spacing","replacedBy":[]},{"ruleId":"comma-style","replacedBy":[]},{"ruleId":"computed-property-spacing","replacedBy":[]},{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"eol-last","replacedBy":[]},{"ruleId":"func-call-spacing","replacedBy":[]},{"ruleId":"generator-star-spacing","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"key-spacing","replacedBy":[]},{"ruleId":"keyword-spacing","replacedBy":[]},{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"multiline-ternary","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-extra-parens","replacedBy":[]},{"ruleId":"no-floating-decimal","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multi-spaces","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-tabs","replacedBy":[]},{"ruleId":"no-trailing-spaces","replacedBy":[]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"object-curly-newline","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"object-property-newline","replacedBy":[]},{"ruleId":"operator-linebreak","replacedBy":[]},{"ruleId":"padded-blocks","replacedBy":[]},{"ruleId":"quote-props","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"semi-spacing","replacedBy":[]},{"ruleId":"space-before-blocks","replacedBy":[]},{"ruleId":"space-before-function-paren","replacedBy":[]},{"ruleId":"space-in-parens","replacedBy":[]},{"ruleId":"space-infix-ops","replacedBy":[]},{"ruleId":"space-unary-ops","replacedBy":[]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"template-tag-spacing","replacedBy":[]},{"ruleId":"wrap-iife","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]}]}]